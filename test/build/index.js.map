{"version":3,"sources":["webpack://JsCrypto/webpack/universalModuleDefinition","webpack://JsCrypto/webpack/bootstrap","webpack://JsCrypto/(webpack)/buildin/global.js","webpack://JsCrypto/./src/AES.ts","webpack://JsCrypto/./src/DES.ts","webpack://JsCrypto/./src/DES3.ts","webpack://JsCrypto/./src/Hmac.ts","webpack://JsCrypto/./src/HmacMD5.ts","webpack://JsCrypto/./src/HmacSHA224.ts","webpack://JsCrypto/./src/HmacSHA256.ts","webpack://JsCrypto/./src/HmacSHA384.ts","webpack://JsCrypto/./src/HmacSHA512.ts","webpack://JsCrypto/./src/MD5.ts","webpack://JsCrypto/./src/RC4.ts","webpack://JsCrypto/./src/RC4Drop.ts","webpack://JsCrypto/./src/RIPEMD160.ts","webpack://JsCrypto/./src/Rabbit.ts","webpack://JsCrypto/./src/SHA1.ts","webpack://JsCrypto/./src/SHA224.ts","webpack://JsCrypto/./src/SHA256.ts","webpack://JsCrypto/./src/SHA3.ts","webpack://JsCrypto/./src/SHA384.ts","webpack://JsCrypto/./src/SHA512.ts","webpack://JsCrypto/./src/index.ts","webpack://JsCrypto/./src/lib/Word32Array.ts","webpack://JsCrypto/./src/lib/Word64Array.ts","webpack://JsCrypto/./src/lib/algorithm/BufferedBlockAlgorithm.ts","webpack://JsCrypto/./src/lib/algorithm/Hasher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/BlockCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/Cipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/CipherParams.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/PasswordBasedCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/SerializableCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/StreamCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/formatter/OpenSSLFormatter.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/OpenSSLKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/module/EvpKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/module/PBKDF2.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/type.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/BlockCipherMode.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/CBC.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/CFB.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/CTR.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/ECB.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/mode/OFB.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/AnsiX923.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/ISO10126.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/ISO97971.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/Noop.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/Pkcs7.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/pad/Zero.ts","webpack://JsCrypto/./src/lib/browser.ts","webpack://JsCrypto/./src/lib/encoder/Base64.ts","webpack://JsCrypto/./src/lib/encoder/Hex.ts","webpack://JsCrypto/./src/lib/encoder/Latin1.ts","webpack://JsCrypto/./src/lib/encoder/Utf16.ts","webpack://JsCrypto/./src/lib/encoder/Utf8.ts","webpack://JsCrypto/./src/lib/index.ts","webpack://JsCrypto/./src/lib/random.ts","webpack://JsCrypto/./src/mode/CBC.ts","webpack://JsCrypto/./src/mode/CFB.ts","webpack://JsCrypto/./src/mode/CTR.ts","webpack://JsCrypto/./src/mode/ECB.ts","webpack://JsCrypto/./src/mode/OFB.ts","webpack://JsCrypto/./src/pad/AnsiX923.ts","webpack://JsCrypto/./src/pad/ISO10126.ts","webpack://JsCrypto/./src/pad/ISO97971.ts","webpack://JsCrypto/./src/pad/Noop.ts","webpack://JsCrypto/./src/pad/Pkcs7.ts","webpack://JsCrypto/./src/pad/Zero.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuD;AACU;AACgB;AACF;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO,kBAAkB,6EAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,qBAAqB,mEAAM,qBAAqB;AAChH;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,qBAAqB,mEAAM,qBAAqB;AAChH;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiE;AACV;AAC0B;AACF;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,6EAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,qBAAqB,mEAAM,qBAAqB;AAChH;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,qBAAqB,mEAAM,qBAAqB;AAChH;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACttBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+E;AACd;AACV;AAC3B;AACoB;AACiC;AAC1E,mBAAmB,6EAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAG,qBAAqB,4DAAW;AACxD,qBAAqB,wCAAG,qBAAqB,4DAAW;AACxD,qBAAqB,wCAAG,qBAAqB,4DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,mEAAmE,kBAAkB;AACrF;AACA;AACA,iDAAiD;AACjD,sDAAsD,WAAW,qBAAqB,mEAAM,qBAAqB;AACjH;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,mEAAmE,kBAAkB;AACrF;AACA;AACA,iDAAiD;AACjD,sDAAsD,WAAW,qBAAqB,mEAAM,qBAAqB;AACjH;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAA0C;AACnC;AACP;AACA;AACA;AACA;AACA,kBAAkB,sDAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAA8B;AACF;AACrB;AACP,eAAe,0CAAI,KAAK,wCAAG;AAC3B;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAA8B;AACI;AAC3B;AACP,eAAe,0CAAI,KAAK,8CAAM;AAC9B;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAA8B;AACI;AAC3B;AACP,eAAe,0CAAI,KAAK,8CAAM;AAC9B;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAA8B;AACI;AAC3B;AACP,eAAe,0CAAI,KAAK,8CAAM;AAC9B;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAA8B;AACI;AAC3B;AACP,eAAe,0CAAI,KAAK,8CAAM;AAC9B;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,4DAAM;AAC/B;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAA;AAAmE;AACc;AACF;AACxE,kBAAkB,+EAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,MAAM;AACtE;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,MAAM;AACtE;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAA;AAAiF;AACF;AACnD;AACrB,sBAAsB,wCAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,iDAAiD;AACjD,yDAAyD,WAAW,MAAM;AAC1E;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,sEAAsE,kBAAkB;AACxF;AACA;AACA,iDAAiD;AACjD,yDAAyD,WAAW,MAAM;AAC1E;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;;;;;;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACgD;AACA;AAChD;AACA,gBAAgB,4DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAW;AAC3B,gBAAgB,4DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,4DAAM;AACrC;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAmE;AACc;AACF;AACxE,qBAAqB,+EAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,MAAM;AACzE;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,qEAAqE,kBAAkB;AACvF;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,MAAM;AACzE;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;;;;;;;;;;;;;AChMA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACO,mBAAmB,4DAAM;AAChC;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAgD;AACd;AAC3B,qBAAqB,8CAAM;AAClC;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO,qBAAqB,4DAAM;AAClC;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACK;AACA;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAM;AACvC;AACA,CAAC;AACD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,uDAAM;AACzB;AACA,CAAC;AACM,mBAAmB,4DAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC,qCAAqC,uDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,iCAAiC,uDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7OA;AAAA;AAAA;AAAA;AAAwD;AACtB;AAC3B,qBAAqB,8CAAM;AAClC;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAgD;AACQ;AACxD;AACA,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,uDAAM;AACzB;AACA,CAAC;AACM,qBAAqB,4DAAM;AAClC;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgJ;AACjE;AACE;AACnD;AACM;AACM;AACA;AACA;AACA;AACd;AACE;AACI;AACA;AACA;AACA;AACJ;AACF;AACA;AACE;AACU;AACN;AACN;AACQ;AACH;AACA;AACA;AACA;AACA;AAC1B;AACP,IAAI,mDAAG;AACP,IAAI,mDAAG;AACP,IAAI,mDAAG;AACP,IAAI,mDAAG;AACP,IAAI,mDAAG;AACP;AAC0C;AACA;AACA;AACN;AACF;AACA;AAC3B;AACP,IAAI,iEAAQ;AACZ,IAAI,iEAAQ;AACZ,IAAI,iEAAQ;AACZ,IAAI,wDAAK;AACT,IAAI,qDAAI;AACR,IAAI,qDAAI;AACR;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAoC;AACF;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,uBAAuB,sDAAM;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACQ;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAA6C;AACN;AAChC;AACP;AACA;AACA;AACA;AACA,2FAA2F,wDAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wDAAW;AACjF;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAkE;AAC3D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACD;AACC;AAC3B,0BAA0B,8CAAM;AACvC;AACA;AACA;AACA,qBAAqB,6CAAG;AACxB,wBAAwB,8CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAA+C;AACxF;AACA;AACA,uDAAuD,+CAA+C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,oEAAoE,kBAAkB;AACtF;AACA;AACA,iDAAiD;AACjD,6DAA6D,WAAW,qBAAqB,8CAAM,qBAAqB;AACxH;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,6DAA6D,WAAW,qBAAqB,8CAAM,qBAAqB;AACxH;AACA;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAmE;AAC5D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,gDAAgD;AACnH;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,uEAAuE,kBAAkB;AACzF;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,gDAAgD;AACnH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAgE;AAChE;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;AACO;AACP;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,4EAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4EAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4E;AAC9B;AACA;AACkB;AACzD;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,mBAAmB;AAClC,eAAe,OAAO;AACtB,eAAe,mCAAmC;AAClD,gBAAgB,aAAa;AAC7B;AACA;AACA,+FAA+F,oCAAoC;AACnI;AACA;AACA,0CAA0C;AAC1C,qDAAqD,0DAAU;AAC/D;AACA;AACA,6BAA6B,sEAAkB;AAC/C,mBAAmB,0DAAY,+BAA+B,kBAAkB,yEAAyE;AACzJ,KAAK;AACL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB,eAAe,mCAAmC;AAClD,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0CAA0C;AAC1C,oCAAoC,0DAAU;AAC9C,sDAAsD,4EAAgB;AACtE,iCAAiC,2EAAe;AAChD;AACA;AACA,eAAe,sEAAkB;AACjC;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAgE;AAClB;AAC9C;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,UAAU;AACrB,YAAY,aAAa;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,mBAAmB;AAClC,eAAe,YAAY;AAC3B,eAAe,kCAAkC;AACjD,gBAAgB,aAAa;AAC7B;AACA;AACA,iGAAiG,SAAS;AAC1G;AACA;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,4EAAgB;AAC1G,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,oBAAoB;AACnC,eAAe,YAAY;AAC3B,eAAe,iCAAiC;AAChD,gBAAgB,YAAY;AAC5B;AACA,wGAAwG,mCAAmC;AAC3I,qGAAqG,mCAAmC;AACxI;AACA;AACA;AACA,4HAA4H,4EAAgB;AAC5I;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAkC;AAC3B,2BAA2B,8CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACI;AACF;AAC1C;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C,sCAAsC,sDAAM;AAC5C;AACA,mCAAmC,sDAAM;AACzC,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAM;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA;AACA,mBAAmB,0DAAY,EAAE,mBAAmB;AACpD;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACJ;AACN;AACzC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA,gDAAgD,qDAAM;AACtD,kCAAkC,qDAAqD;AACvF;AACA,mFAAmF,cAAc,4BAA4B;AAC7H;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA,mBAAmB,0DAAY,EAAE,gBAAgB;AACjD;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACa;AACd;AACxC;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO,qBAAqB,mDAAa;AACzC;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACA;AACW;AACd;AACxC;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO,qBAAqB,mDAAa;AACzC;AACA;AACA;AACA,uBAAuB,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA,+BAA+B,wDAAW;AAC1C,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAoD;AAC7C,kBAAkB,gEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACO,kBAAkB,gEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACO,kBAAkB,gEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACO,kBAAkB,gEAAe;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACO,kBAAkB,gEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAmD;AACnD;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B,oBAAoB,wDAAW;AAC/B;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAmD;AACrB;AAC9B;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAW;AAC/B;AACA,IAAI,0CAAI;AACR;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI,0CAAI;AACR;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAmD;AACnD;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,wBAAwB,wDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAA6C;AAC7C;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAA6C;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACO;;;;;;;;;;;;;ACxFP;AAAA;AAAA;AAAkC;AAC3B;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAM;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACU;AACQ;AACnB;AACS;AACJ;AACI;AACN;AACsB;AACK;AACD;AACA;;;;;;;;;;;;;ACX9D;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAA6B;AAC1C;AACA;AACA;AACA,mBAAmB,OAAuB;AAC1C;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;ACxBP;AAAA;AAAA;AAAA;AAAuD;;;;;;;;;;;;;ACAvD;AAAA;AAAA;AAAA;AAAuD;;;;;;;;;;;;;ACAvD;AAAA;AAAA;AAAA;AAAuD;;;;;;;;;;;;;ACAvD;AAAA;AAAA;AAAA;AAAuD;;;;;;;;;;;;;ACAvD;AAAA;AAAA;AAAA;AAAuD;;;;;;;;;;;;;ACAvD;AAAA;AAAA;AAAA;AAAgE;;;;;;;;;;;;;ACAhE;AAAA;AAAA;AAAA;AAAgE;;;;;;;;;;;;;ACAhE;AAAA;AAAA;AAAA;AAAgE;;;;;;;;;;;;;ACAhE;AAAA;AAAA;AAAA;AAAwD;;;;;;;;;;;;;ACAxD;AAAA;AAAA;AAAA;AAA0D;;;;;;;;;;;;;ACA1D;AAAA;AAAA;AAAA;AAAwD","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsCrypto\"] = factory();\n\telse\n\t\troot[\"JsCrypto\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Cipher } from \"./lib/algorithm/cipher/Cipher\";\r\nimport { BlockCipher } from \"./lib/algorithm/cipher/BlockCipher\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\n// Lookup tables\r\nconst SBOX = [];\r\nconst INV_SBOX = [];\r\nconst SUB_MIX_0 = [];\r\nconst SUB_MIX_1 = [];\r\nconst SUB_MIX_2 = [];\r\nconst SUB_MIX_3 = [];\r\nconst INV_SUB_MIX_0 = [];\r\nconst INV_SUB_MIX_1 = [];\r\nconst INV_SUB_MIX_2 = [];\r\nconst INV_SUB_MIX_3 = [];\r\n(function computeLookupTables() {\r\n    // Compute double table\r\n    const d = [];\r\n    for (let i = 0; i < 256; i++) {\r\n        if (i < 128) {\r\n            d[i] = i << 1;\r\n        }\r\n        else {\r\n            d[i] = (i << 1) ^ 0x11b;\r\n        }\r\n    }\r\n    // Walk GF(2^8)\r\n    let x = 0;\r\n    let xi = 0;\r\n    for (let i = 0; i < 256; i++) {\r\n        // Compute sbox\r\n        let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\r\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\r\n        SBOX[x] = sx;\r\n        INV_SBOX[sx] = x;\r\n        // Compute multiplication\r\n        const x2 = d[x];\r\n        const x4 = d[x2];\r\n        const x8 = d[x4];\r\n        // Compute sub bytes, mix columns tables\r\n        let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\r\n        SUB_MIX_0[x] = (t << 24) | (t >>> 8);\r\n        SUB_MIX_1[x] = (t << 16) | (t >>> 16);\r\n        SUB_MIX_2[x] = (t << 8) | (t >>> 24);\r\n        SUB_MIX_3[x] = t;\r\n        // Compute inv sub bytes, inv mix columns tables\r\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\r\n        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\r\n        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\r\n        INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\r\n        INV_SUB_MIX_3[sx] = t;\r\n        // Compute next counter\r\n        if (!x) {\r\n            x = xi = 1;\r\n        }\r\n        else {\r\n            x = x2 ^ d[d[d[x8 ^ x2]]];\r\n            xi ^= d[d[xi]];\r\n        }\r\n    }\r\n}());\r\n// Precomputed Rcon lookup\r\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\r\nexport class AES extends BlockCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._nRounds = 0;\r\n        this._keySchedule = [];\r\n        this._invKeySchedule = [];\r\n        this._props = props;\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        let t;\r\n        // Skip reset of nRounds has been set before and key did not change\r\n        if (this._nRounds && this._keyPriorReset === this._key) {\r\n            return;\r\n        }\r\n        // Shortcuts\r\n        const key = this._keyPriorReset = this._key;\r\n        const keyWords = key.words;\r\n        const keySize = key.nSigBytes / 4;\r\n        // Compute number of rounds\r\n        const nRounds = this._nRounds = keySize + 6;\r\n        // Compute number of key schedule rows\r\n        const ksRows = (nRounds + 1) * 4;\r\n        // Compute key schedule\r\n        const keySchedule = this._keySchedule = [];\r\n        for (let ksRow = 0; ksRow < ksRows; ksRow++) {\r\n            if (ksRow < keySize) {\r\n                keySchedule[ksRow] = keyWords[ksRow];\r\n            }\r\n            else {\r\n                t = keySchedule[ksRow - 1];\r\n                if (!(ksRow % keySize)) {\r\n                    // Rot word\r\n                    t = (t << 8) | (t >>> 24);\r\n                    // Sub word\r\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\r\n                    // Mix Rcon\r\n                    t ^= RCON[(ksRow / keySize) | 0] << 24;\r\n                }\r\n                else if (keySize > 6 && ksRow % keySize === 4) {\r\n                    // Sub word\r\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\r\n                }\r\n                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\r\n            }\r\n        }\r\n        // Compute inv key schedule\r\n        this._invKeySchedule = [];\r\n        for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {\r\n            const ksRow = ksRows - invKsRow;\r\n            if (invKsRow % 4) {\r\n                t = keySchedule[ksRow];\r\n            }\r\n            else {\r\n                t = keySchedule[ksRow - 4];\r\n            }\r\n            if (invKsRow < 4 || ksRow <= 4) {\r\n                this._invKeySchedule[invKsRow] = t;\r\n            }\r\n            else {\r\n                this._invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\r\n                    INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\r\n            }\r\n        }\r\n    }\r\n    encryptBlock(words, offset) {\r\n        this._doCryptBlock(words, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\r\n    }\r\n    decryptBlock(words, offset) {\r\n        // Swap 2nd and 4th rows\r\n        let t = words[offset + 1];\r\n        words[offset + 1] = words[offset + 3];\r\n        words[offset + 3] = t;\r\n        this._doCryptBlock(words, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\r\n        // Inv swap 2nd and 4th rows\r\n        t = words[offset + 1];\r\n        words[offset + 1] = words[offset + 3];\r\n        words[offset + 3] = t;\r\n    }\r\n    _doCryptBlock(words, offset, keySchedule, subMix0, subMix1, subMix2, subMix3, sBox) {\r\n        // Shortcut\r\n        const nRounds = this._nRounds;\r\n        // Get input, add round key\r\n        let s0 = words[offset] ^ keySchedule[0];\r\n        let s1 = words[offset + 1] ^ keySchedule[1];\r\n        let s2 = words[offset + 2] ^ keySchedule[2];\r\n        let s3 = words[offset + 3] ^ keySchedule[3];\r\n        // Key schedule row counter\r\n        let ksRow = 4;\r\n        // Rounds\r\n        for (let round = 1; round < nRounds; round++) {\r\n            // Shift rows, sub bytes, mix columns, add round key\r\n            const _s0 = subMix0[s0 >>> 24] ^ subMix1[(s1 >>> 16) & 0xff]\r\n                ^ subMix2[(s2 >>> 8) & 0xff] ^ subMix3[s3 & 0xff] ^ keySchedule[ksRow++];\r\n            const _s1 = subMix0[s1 >>> 24] ^ subMix1[(s2 >>> 16) & 0xff]\r\n                ^ subMix2[(s3 >>> 8) & 0xff] ^ subMix3[s0 & 0xff] ^ keySchedule[ksRow++];\r\n            const _s2 = subMix0[s2 >>> 24] ^ subMix1[(s3 >>> 16) & 0xff]\r\n                ^ subMix2[(s0 >>> 8) & 0xff] ^ subMix3[s1 & 0xff] ^ keySchedule[ksRow++];\r\n            const _s3 = subMix0[s3 >>> 24] ^ subMix1[(s0 >>> 16) & 0xff]\r\n                ^ subMix2[(s1 >>> 8) & 0xff] ^ subMix3[s2 & 0xff] ^ keySchedule[ksRow++];\r\n            // Update state\r\n            s0 = _s0;\r\n            s1 = _s1;\r\n            s2 = _s2;\r\n            s3 = _s3;\r\n        }\r\n        // Shift rows, sub bytes, add round key\r\n        const t0 = ((sBox[s0 >>> 24] << 24) | (sBox[(s1 >>> 16) & 0xff] << 16)\r\n            | (sBox[(s2 >>> 8) & 0xff] << 8) | sBox[s3 & 0xff]) ^ keySchedule[ksRow++];\r\n        const t1 = ((sBox[s1 >>> 24] << 24) | (sBox[(s2 >>> 16) & 0xff] << 16)\r\n            | (sBox[(s3 >>> 8) & 0xff] << 8) | sBox[s0 & 0xff]) ^ keySchedule[ksRow++];\r\n        const t2 = ((sBox[s2 >>> 24] << 24) | (sBox[(s3 >>> 16) & 0xff] << 16)\r\n            | (sBox[(s0 >>> 8) & 0xff] << 8) | sBox[s1 & 0xff]) ^ keySchedule[ksRow++];\r\n        const t3 = ((sBox[s3 >>> 24] << 24) | (sBox[(s0 >>> 16) & 0xff] << 16)\r\n            | (sBox[(s1 >>> 8) & 0xff] << 8) | sBox[s2 & 0xff]) ^ keySchedule[ksRow++];\r\n        // Set output\r\n        words[offset] = t0;\r\n        words[offset + 1] = t1;\r\n        words[offset + 2] = t2;\r\n        words[offset + 3] = t3;\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new AES(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new AES(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.AES.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(AES, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(AES, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.AES.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(AES, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(AES, cipherText, key, props);\r\n    }\r\n}\r\nAES.keySize = 256 / 32;\r\n","// Permuted Choice 1 constants\r\nimport { BlockCipher } from \"./lib/algorithm/cipher/BlockCipher\";\r\nimport { Cipher } from \"./lib/algorithm/cipher/Cipher\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nconst PC1 = [\r\n    57, 49, 41, 33, 25, 17, 9, 1,\r\n    58, 50, 42, 34, 26, 18, 10, 2,\r\n    59, 51, 43, 35, 27, 19, 11, 3,\r\n    60, 52, 44, 36, 63, 55, 47, 39,\r\n    31, 23, 15, 7, 62, 54, 46, 38,\r\n    30, 22, 14, 6, 61, 53, 45, 37,\r\n    29, 21, 13, 5, 28, 20, 12, 4\r\n];\r\n// Permuted Choice 2 constants\r\nconst PC2 = [\r\n    14, 17, 11, 24, 1, 5,\r\n    3, 28, 15, 6, 21, 10,\r\n    23, 19, 12, 4, 26, 8,\r\n    16, 7, 27, 20, 13, 2,\r\n    41, 52, 31, 37, 47, 55,\r\n    30, 40, 51, 45, 33, 48,\r\n    44, 49, 39, 56, 34, 53,\r\n    46, 42, 50, 36, 29, 32\r\n];\r\n// Cumulative bit shift constants\r\nconst BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\r\n// SBOXes and round permutation constants\r\nconst SBOX_P = [\r\n    {\r\n        0x0: 0x808200,\r\n        0x10000000: 0x8000,\r\n        0x20000000: 0x808002,\r\n        0x30000000: 0x2,\r\n        0x40000000: 0x200,\r\n        0x50000000: 0x808202,\r\n        0x60000000: 0x800202,\r\n        0x70000000: 0x800000,\r\n        0x80000000: 0x202,\r\n        0x90000000: 0x800200,\r\n        0xa0000000: 0x8200,\r\n        0xb0000000: 0x808000,\r\n        0xc0000000: 0x8002,\r\n        0xd0000000: 0x800002,\r\n        0xe0000000: 0x0,\r\n        0xf0000000: 0x8202,\r\n        0x8000000: 0x0,\r\n        0x18000000: 0x808202,\r\n        0x28000000: 0x8202,\r\n        0x38000000: 0x8000,\r\n        0x48000000: 0x808200,\r\n        0x58000000: 0x200,\r\n        0x68000000: 0x808002,\r\n        0x78000000: 0x2,\r\n        0x88000000: 0x800200,\r\n        0x98000000: 0x8200,\r\n        0xa8000000: 0x808000,\r\n        0xb8000000: 0x800202,\r\n        0xc8000000: 0x800002,\r\n        0xd8000000: 0x8002,\r\n        0xe8000000: 0x202,\r\n        0xf8000000: 0x800000,\r\n        0x1: 0x8000,\r\n        0x10000001: 0x2,\r\n        0x20000001: 0x808200,\r\n        0x30000001: 0x800000,\r\n        0x40000001: 0x808002,\r\n        0x50000001: 0x8200,\r\n        0x60000001: 0x200,\r\n        0x70000001: 0x800202,\r\n        0x80000001: 0x808202,\r\n        0x90000001: 0x808000,\r\n        0xa0000001: 0x800002,\r\n        0xb0000001: 0x8202,\r\n        0xc0000001: 0x202,\r\n        0xd0000001: 0x800200,\r\n        0xe0000001: 0x8002,\r\n        0xf0000001: 0x0,\r\n        0x8000001: 0x808202,\r\n        0x18000001: 0x808000,\r\n        0x28000001: 0x800000,\r\n        0x38000001: 0x200,\r\n        0x48000001: 0x8000,\r\n        0x58000001: 0x800002,\r\n        0x68000001: 0x2,\r\n        0x78000001: 0x8202,\r\n        0x88000001: 0x8002,\r\n        0x98000001: 0x800202,\r\n        0xa8000001: 0x202,\r\n        0xb8000001: 0x808200,\r\n        0xc8000001: 0x800200,\r\n        0xd8000001: 0x0,\r\n        0xe8000001: 0x8200,\r\n        0xf8000001: 0x808002\r\n    },\r\n    {\r\n        0x0: 0x40084010,\r\n        0x1000000: 0x4000,\r\n        0x2000000: 0x80000,\r\n        0x3000000: 0x40080010,\r\n        0x4000000: 0x40000010,\r\n        0x5000000: 0x40084000,\r\n        0x6000000: 0x40004000,\r\n        0x7000000: 0x10,\r\n        0x8000000: 0x84000,\r\n        0x9000000: 0x40004010,\r\n        0xa000000: 0x40000000,\r\n        0xb000000: 0x84010,\r\n        0xc000000: 0x80010,\r\n        0xd000000: 0x0,\r\n        0xe000000: 0x4010,\r\n        0xf000000: 0x40080000,\r\n        0x800000: 0x40004000,\r\n        0x1800000: 0x84010,\r\n        0x2800000: 0x10,\r\n        0x3800000: 0x40004010,\r\n        0x4800000: 0x40084010,\r\n        0x5800000: 0x40000000,\r\n        0x6800000: 0x80000,\r\n        0x7800000: 0x40080010,\r\n        0x8800000: 0x80010,\r\n        0x9800000: 0x0,\r\n        0xa800000: 0x4000,\r\n        0xb800000: 0x40080000,\r\n        0xc800000: 0x40000010,\r\n        0xd800000: 0x84000,\r\n        0xe800000: 0x40084000,\r\n        0xf800000: 0x4010,\r\n        0x10000000: 0x0,\r\n        0x11000000: 0x40080010,\r\n        0x12000000: 0x40004010,\r\n        0x13000000: 0x40084000,\r\n        0x14000000: 0x40080000,\r\n        0x15000000: 0x10,\r\n        0x16000000: 0x84010,\r\n        0x17000000: 0x4000,\r\n        0x18000000: 0x4010,\r\n        0x19000000: 0x80000,\r\n        0x1a000000: 0x80010,\r\n        0x1b000000: 0x40000010,\r\n        0x1c000000: 0x84000,\r\n        0x1d000000: 0x40004000,\r\n        0x1e000000: 0x40000000,\r\n        0x1f000000: 0x40084010,\r\n        0x10800000: 0x84010,\r\n        0x11800000: 0x80000,\r\n        0x12800000: 0x40080000,\r\n        0x13800000: 0x4000,\r\n        0x14800000: 0x40004000,\r\n        0x15800000: 0x40084010,\r\n        0x16800000: 0x10,\r\n        0x17800000: 0x40000000,\r\n        0x18800000: 0x40084000,\r\n        0x19800000: 0x40000010,\r\n        0x1a800000: 0x40004010,\r\n        0x1b800000: 0x80010,\r\n        0x1c800000: 0x0,\r\n        0x1d800000: 0x4010,\r\n        0x1e800000: 0x40080010,\r\n        0x1f800000: 0x84000\r\n    },\r\n    {\r\n        0x0: 0x104,\r\n        0x100000: 0x0,\r\n        0x200000: 0x4000100,\r\n        0x300000: 0x10104,\r\n        0x400000: 0x10004,\r\n        0x500000: 0x4000004,\r\n        0x600000: 0x4010104,\r\n        0x700000: 0x4010000,\r\n        0x800000: 0x4000000,\r\n        0x900000: 0x4010100,\r\n        0xa00000: 0x10100,\r\n        0xb00000: 0x4010004,\r\n        0xc00000: 0x4000104,\r\n        0xd00000: 0x10000,\r\n        0xe00000: 0x4,\r\n        0xf00000: 0x100,\r\n        0x80000: 0x4010100,\r\n        0x180000: 0x4010004,\r\n        0x280000: 0x0,\r\n        0x380000: 0x4000100,\r\n        0x480000: 0x4000004,\r\n        0x580000: 0x10000,\r\n        0x680000: 0x10004,\r\n        0x780000: 0x104,\r\n        0x880000: 0x4,\r\n        0x980000: 0x100,\r\n        0xa80000: 0x4010000,\r\n        0xb80000: 0x10104,\r\n        0xc80000: 0x10100,\r\n        0xd80000: 0x4000104,\r\n        0xe80000: 0x4010104,\r\n        0xf80000: 0x4000000,\r\n        0x1000000: 0x4010100,\r\n        0x1100000: 0x10004,\r\n        0x1200000: 0x10000,\r\n        0x1300000: 0x4000100,\r\n        0x1400000: 0x100,\r\n        0x1500000: 0x4010104,\r\n        0x1600000: 0x4000004,\r\n        0x1700000: 0x0,\r\n        0x1800000: 0x4000104,\r\n        0x1900000: 0x4000000,\r\n        0x1a00000: 0x4,\r\n        0x1b00000: 0x10100,\r\n        0x1c00000: 0x4010000,\r\n        0x1d00000: 0x104,\r\n        0x1e00000: 0x10104,\r\n        0x1f00000: 0x4010004,\r\n        0x1080000: 0x4000000,\r\n        0x1180000: 0x104,\r\n        0x1280000: 0x4010100,\r\n        0x1380000: 0x0,\r\n        0x1480000: 0x10004,\r\n        0x1580000: 0x4000100,\r\n        0x1680000: 0x100,\r\n        0x1780000: 0x4010004,\r\n        0x1880000: 0x10000,\r\n        0x1980000: 0x4010104,\r\n        0x1a80000: 0x10104,\r\n        0x1b80000: 0x4000004,\r\n        0x1c80000: 0x4000104,\r\n        0x1d80000: 0x4010000,\r\n        0x1e80000: 0x4,\r\n        0x1f80000: 0x10100\r\n    },\r\n    {\r\n        0x0: 0x80401000,\r\n        0x10000: 0x80001040,\r\n        0x20000: 0x401040,\r\n        0x30000: 0x80400000,\r\n        0x40000: 0x0,\r\n        0x50000: 0x401000,\r\n        0x60000: 0x80000040,\r\n        0x70000: 0x400040,\r\n        0x80000: 0x80000000,\r\n        0x90000: 0x400000,\r\n        0xa0000: 0x40,\r\n        0xb0000: 0x80001000,\r\n        0xc0000: 0x80400040,\r\n        0xd0000: 0x1040,\r\n        0xe0000: 0x1000,\r\n        0xf0000: 0x80401040,\r\n        0x8000: 0x80001040,\r\n        0x18000: 0x40,\r\n        0x28000: 0x80400040,\r\n        0x38000: 0x80001000,\r\n        0x48000: 0x401000,\r\n        0x58000: 0x80401040,\r\n        0x68000: 0x0,\r\n        0x78000: 0x80400000,\r\n        0x88000: 0x1000,\r\n        0x98000: 0x80401000,\r\n        0xa8000: 0x400000,\r\n        0xb8000: 0x1040,\r\n        0xc8000: 0x80000000,\r\n        0xd8000: 0x400040,\r\n        0xe8000: 0x401040,\r\n        0xf8000: 0x80000040,\r\n        0x100000: 0x400040,\r\n        0x110000: 0x401000,\r\n        0x120000: 0x80000040,\r\n        0x130000: 0x0,\r\n        0x140000: 0x1040,\r\n        0x150000: 0x80400040,\r\n        0x160000: 0x80401000,\r\n        0x170000: 0x80001040,\r\n        0x180000: 0x80401040,\r\n        0x190000: 0x80000000,\r\n        0x1a0000: 0x80400000,\r\n        0x1b0000: 0x401040,\r\n        0x1c0000: 0x80001000,\r\n        0x1d0000: 0x400000,\r\n        0x1e0000: 0x40,\r\n        0x1f0000: 0x1000,\r\n        0x108000: 0x80400000,\r\n        0x118000: 0x80401040,\r\n        0x128000: 0x0,\r\n        0x138000: 0x401000,\r\n        0x148000: 0x400040,\r\n        0x158000: 0x80000000,\r\n        0x168000: 0x80001040,\r\n        0x178000: 0x40,\r\n        0x188000: 0x80000040,\r\n        0x198000: 0x1000,\r\n        0x1a8000: 0x80001000,\r\n        0x1b8000: 0x80400040,\r\n        0x1c8000: 0x1040,\r\n        0x1d8000: 0x80401000,\r\n        0x1e8000: 0x400000,\r\n        0x1f8000: 0x401040\r\n    },\r\n    {\r\n        0x0: 0x80,\r\n        0x1000: 0x1040000,\r\n        0x2000: 0x40000,\r\n        0x3000: 0x20000000,\r\n        0x4000: 0x20040080,\r\n        0x5000: 0x1000080,\r\n        0x6000: 0x21000080,\r\n        0x7000: 0x40080,\r\n        0x8000: 0x1000000,\r\n        0x9000: 0x20040000,\r\n        0xa000: 0x20000080,\r\n        0xb000: 0x21040080,\r\n        0xc000: 0x21040000,\r\n        0xd000: 0x0,\r\n        0xe000: 0x1040080,\r\n        0xf000: 0x21000000,\r\n        0x800: 0x1040080,\r\n        0x1800: 0x21000080,\r\n        0x2800: 0x80,\r\n        0x3800: 0x1040000,\r\n        0x4800: 0x40000,\r\n        0x5800: 0x20040080,\r\n        0x6800: 0x21040000,\r\n        0x7800: 0x20000000,\r\n        0x8800: 0x20040000,\r\n        0x9800: 0x0,\r\n        0xa800: 0x21040080,\r\n        0xb800: 0x1000080,\r\n        0xc800: 0x20000080,\r\n        0xd800: 0x21000000,\r\n        0xe800: 0x1000000,\r\n        0xf800: 0x40080,\r\n        0x10000: 0x40000,\r\n        0x11000: 0x80,\r\n        0x12000: 0x20000000,\r\n        0x13000: 0x21000080,\r\n        0x14000: 0x1000080,\r\n        0x15000: 0x21040000,\r\n        0x16000: 0x20040080,\r\n        0x17000: 0x1000000,\r\n        0x18000: 0x21040080,\r\n        0x19000: 0x21000000,\r\n        0x1a000: 0x1040000,\r\n        0x1b000: 0x20040000,\r\n        0x1c000: 0x40080,\r\n        0x1d000: 0x20000080,\r\n        0x1e000: 0x0,\r\n        0x1f000: 0x1040080,\r\n        0x10800: 0x21000080,\r\n        0x11800: 0x1000000,\r\n        0x12800: 0x1040000,\r\n        0x13800: 0x20040080,\r\n        0x14800: 0x20000000,\r\n        0x15800: 0x1040080,\r\n        0x16800: 0x80,\r\n        0x17800: 0x21040000,\r\n        0x18800: 0x40080,\r\n        0x19800: 0x21040080,\r\n        0x1a800: 0x0,\r\n        0x1b800: 0x21000000,\r\n        0x1c800: 0x1000080,\r\n        0x1d800: 0x40000,\r\n        0x1e800: 0x20040000,\r\n        0x1f800: 0x20000080\r\n    },\r\n    {\r\n        0x0: 0x10000008,\r\n        0x100: 0x2000,\r\n        0x200: 0x10200000,\r\n        0x300: 0x10202008,\r\n        0x400: 0x10002000,\r\n        0x500: 0x200000,\r\n        0x600: 0x200008,\r\n        0x700: 0x10000000,\r\n        0x800: 0x0,\r\n        0x900: 0x10002008,\r\n        0xa00: 0x202000,\r\n        0xb00: 0x8,\r\n        0xc00: 0x10200008,\r\n        0xd00: 0x202008,\r\n        0xe00: 0x2008,\r\n        0xf00: 0x10202000,\r\n        0x80: 0x10200000,\r\n        0x180: 0x10202008,\r\n        0x280: 0x8,\r\n        0x380: 0x200000,\r\n        0x480: 0x202008,\r\n        0x580: 0x10000008,\r\n        0x680: 0x10002000,\r\n        0x780: 0x2008,\r\n        0x880: 0x200008,\r\n        0x980: 0x2000,\r\n        0xa80: 0x10002008,\r\n        0xb80: 0x10200008,\r\n        0xc80: 0x0,\r\n        0xd80: 0x10202000,\r\n        0xe80: 0x202000,\r\n        0xf80: 0x10000000,\r\n        0x1000: 0x10002000,\r\n        0x1100: 0x10200008,\r\n        0x1200: 0x10202008,\r\n        0x1300: 0x2008,\r\n        0x1400: 0x200000,\r\n        0x1500: 0x10000000,\r\n        0x1600: 0x10000008,\r\n        0x1700: 0x202000,\r\n        0x1800: 0x202008,\r\n        0x1900: 0x0,\r\n        0x1a00: 0x8,\r\n        0x1b00: 0x10200000,\r\n        0x1c00: 0x2000,\r\n        0x1d00: 0x10002008,\r\n        0x1e00: 0x10202000,\r\n        0x1f00: 0x200008,\r\n        0x1080: 0x8,\r\n        0x1180: 0x202000,\r\n        0x1280: 0x200000,\r\n        0x1380: 0x10000008,\r\n        0x1480: 0x10002000,\r\n        0x1580: 0x2008,\r\n        0x1680: 0x10202008,\r\n        0x1780: 0x10200000,\r\n        0x1880: 0x10202000,\r\n        0x1980: 0x10200008,\r\n        0x1a80: 0x2000,\r\n        0x1b80: 0x202008,\r\n        0x1c80: 0x200008,\r\n        0x1d80: 0x0,\r\n        0x1e80: 0x10000000,\r\n        0x1f80: 0x10002008\r\n    },\r\n    {\r\n        0x0: 0x100000,\r\n        0x10: 0x2000401,\r\n        0x20: 0x400,\r\n        0x30: 0x100401,\r\n        0x40: 0x2100401,\r\n        0x50: 0x0,\r\n        0x60: 0x1,\r\n        0x70: 0x2100001,\r\n        0x80: 0x2000400,\r\n        0x90: 0x100001,\r\n        0xa0: 0x2000001,\r\n        0xb0: 0x2100400,\r\n        0xc0: 0x2100000,\r\n        0xd0: 0x401,\r\n        0xe0: 0x100400,\r\n        0xf0: 0x2000000,\r\n        0x8: 0x2100001,\r\n        0x18: 0x0,\r\n        0x28: 0x2000401,\r\n        0x38: 0x2100400,\r\n        0x48: 0x100000,\r\n        0x58: 0x2000001,\r\n        0x68: 0x2000000,\r\n        0x78: 0x401,\r\n        0x88: 0x100401,\r\n        0x98: 0x2000400,\r\n        0xa8: 0x2100000,\r\n        0xb8: 0x100001,\r\n        0xc8: 0x400,\r\n        0xd8: 0x2100401,\r\n        0xe8: 0x1,\r\n        0xf8: 0x100400,\r\n        0x100: 0x2000000,\r\n        0x110: 0x100000,\r\n        0x120: 0x2000401,\r\n        0x130: 0x2100001,\r\n        0x140: 0x100001,\r\n        0x150: 0x2000400,\r\n        0x160: 0x2100400,\r\n        0x170: 0x100401,\r\n        0x180: 0x401,\r\n        0x190: 0x2100401,\r\n        0x1a0: 0x100400,\r\n        0x1b0: 0x1,\r\n        0x1c0: 0x0,\r\n        0x1d0: 0x2100000,\r\n        0x1e0: 0x2000001,\r\n        0x1f0: 0x400,\r\n        0x108: 0x100400,\r\n        0x118: 0x2000401,\r\n        0x128: 0x2100001,\r\n        0x138: 0x1,\r\n        0x148: 0x2000000,\r\n        0x158: 0x100000,\r\n        0x168: 0x401,\r\n        0x178: 0x2100400,\r\n        0x188: 0x2000001,\r\n        0x198: 0x2100000,\r\n        0x1a8: 0x0,\r\n        0x1b8: 0x2100401,\r\n        0x1c8: 0x100401,\r\n        0x1d8: 0x400,\r\n        0x1e8: 0x2000400,\r\n        0x1f8: 0x100001\r\n    },\r\n    {\r\n        0x0: 0x8000820,\r\n        0x1: 0x20000,\r\n        0x2: 0x8000000,\r\n        0x3: 0x20,\r\n        0x4: 0x20020,\r\n        0x5: 0x8020820,\r\n        0x6: 0x8020800,\r\n        0x7: 0x800,\r\n        0x8: 0x8020000,\r\n        0x9: 0x8000800,\r\n        0xa: 0x20800,\r\n        0xb: 0x8020020,\r\n        0xc: 0x820,\r\n        0xd: 0x0,\r\n        0xe: 0x8000020,\r\n        0xf: 0x20820,\r\n        0x80000000: 0x800,\r\n        0x80000001: 0x8020820,\r\n        0x80000002: 0x8000820,\r\n        0x80000003: 0x8000000,\r\n        0x80000004: 0x8020000,\r\n        0x80000005: 0x20800,\r\n        0x80000006: 0x20820,\r\n        0x80000007: 0x20,\r\n        0x80000008: 0x8000020,\r\n        0x80000009: 0x820,\r\n        0x8000000a: 0x20020,\r\n        0x8000000b: 0x8020800,\r\n        0x8000000c: 0x0,\r\n        0x8000000d: 0x8020020,\r\n        0x8000000e: 0x8000800,\r\n        0x8000000f: 0x20000,\r\n        0x10: 0x20820,\r\n        0x11: 0x8020800,\r\n        0x12: 0x20,\r\n        0x13: 0x800,\r\n        0x14: 0x8000800,\r\n        0x15: 0x8000020,\r\n        0x16: 0x8020020,\r\n        0x17: 0x20000,\r\n        0x18: 0x0,\r\n        0x19: 0x20020,\r\n        0x1a: 0x8020000,\r\n        0x1b: 0x8000820,\r\n        0x1c: 0x8020820,\r\n        0x1d: 0x20800,\r\n        0x1e: 0x820,\r\n        0x1f: 0x8000000,\r\n        0x80000010: 0x20000,\r\n        0x80000011: 0x800,\r\n        0x80000012: 0x8020020,\r\n        0x80000013: 0x20820,\r\n        0x80000014: 0x20,\r\n        0x80000015: 0x8020000,\r\n        0x80000016: 0x8000000,\r\n        0x80000017: 0x8000820,\r\n        0x80000018: 0x8020820,\r\n        0x80000019: 0x8000020,\r\n        0x8000001a: 0x8000800,\r\n        0x8000001b: 0x0,\r\n        0x8000001c: 0x20800,\r\n        0x8000001d: 0x820,\r\n        0x8000001e: 0x20020,\r\n        0x8000001f: 0x8020800\r\n    }\r\n];\r\n// Masks that select the SBOX input\r\nconst SBOX_MASK = [\r\n    0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\r\n    0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\r\n];\r\nexport class DES extends BlockCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._subKeys = [];\r\n        this._invSubKeys = [];\r\n        this._lBlock = 0;\r\n        this._rBlock = 0;\r\n        this._props = props;\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        // Shortcuts\r\n        const key = this._key;\r\n        const keyWords = key.words;\r\n        // Select 56 bits according to PC1\r\n        const keyBits = [];\r\n        for (let i = 0; i < 56; i++) {\r\n            const keyBitPos = PC1[i] - 1;\r\n            keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\r\n        }\r\n        // Assemble 16 subkeys\r\n        const subKeys = this._subKeys = [];\r\n        for (let nSubKey = 0; nSubKey < 16; nSubKey++) {\r\n            // Create subkey\r\n            const subKey = subKeys[nSubKey] = [];\r\n            // Shortcut\r\n            const bitShift = BIT_SHIFTS[nSubKey];\r\n            // Select 48 bits according to PC2\r\n            for (let i = 0; i < 24; i++) {\r\n                // Select from the left 28 key bits\r\n                subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\r\n                // Select from the right 28 key bits\r\n                subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\r\n            }\r\n            // Since each subkey is applied to an expanded 32-bit input,\r\n            // the subkey can be broken into 8 values scaled to 32-bits,\r\n            // which allows the key to be used without expansion\r\n            subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\r\n            for (let i = 1; i < 7; i++) {\r\n                subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\r\n            }\r\n            subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\r\n        }\r\n        // Compute inverse subkeys\r\n        this._invSubKeys = [];\r\n        for (let i = 0; i < 16; i++) {\r\n            this._invSubKeys[i] = subKeys[15 - i];\r\n        }\r\n    }\r\n    encryptBlock(words, offset) {\r\n        this._doCryptoBlock(words, offset, this._subKeys);\r\n    }\r\n    decryptBlock(words, offset) {\r\n        this._doCryptoBlock(words, offset, this._invSubKeys);\r\n    }\r\n    _doCryptoBlock(words, offset, subKeys) {\r\n        // Get input\r\n        this._lBlock = words[offset];\r\n        this._rBlock = words[offset + 1];\r\n        // Initial permutation\r\n        this._exchangeLR(4, 0x0f0f0f0f);\r\n        this._exchangeLR(16, 0x0000ffff);\r\n        this._exchangeRL(2, 0x33333333);\r\n        this._exchangeRL(8, 0x00ff00ff);\r\n        this._exchangeLR(1, 0x55555555);\r\n        // Rounds\r\n        for (let round = 0; round < 16; round++) {\r\n            // Shortcuts\r\n            const subKey = subKeys[round];\r\n            const lBlock = this._lBlock;\r\n            const rBlock = this._rBlock;\r\n            // Feistel function\r\n            let f = 0;\r\n            for (let i = 0; i < 8; i++) {\r\n                const s = ((rBlock ^ subKey[i]) & SBOX_MASK[i]);\r\n                f |= SBOX_P[i][s >>> 0];\r\n            }\r\n            this._lBlock = rBlock;\r\n            this._rBlock = lBlock ^ f;\r\n        }\r\n        // Undo swap from last round\r\n        const t = this._lBlock;\r\n        this._lBlock = this._rBlock;\r\n        this._rBlock = t;\r\n        // Final permutation\r\n        this._exchangeLR(1, 0x55555555);\r\n        this._exchangeRL(8, 0x00ff00ff);\r\n        this._exchangeRL(2, 0x33333333);\r\n        this._exchangeLR(16, 0x0000ffff);\r\n        this._exchangeLR(4, 0x0f0f0f0f);\r\n        // Set output\r\n        words[offset] = this._lBlock;\r\n        words[offset + 1] = this._rBlock;\r\n    }\r\n    _exchangeLR(offset, mask) {\r\n        const t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\r\n        this._rBlock ^= t;\r\n        this._lBlock ^= t << offset;\r\n    }\r\n    _exchangeRL(offset, mask) {\r\n        const t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\r\n        this._lBlock ^= t;\r\n        this._rBlock ^= t << offset;\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.DES.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new DES(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.DES.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new DES(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.DES.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(DES, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(DES, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.DES.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(DES, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(DES, cipherText, key, props);\r\n    }\r\n}\r\nDES.keySize = 64 / 32;\r\nDES.ivSize = 64 / 32;\r\nDES._blockSize = 64 / 32;\r\n","import { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nimport { BlockCipher } from \"./lib/algorithm/cipher/BlockCipher\";\r\nimport { Cipher } from \"./lib/algorithm/cipher/Cipher\";\r\nimport { DES } from \"./DES\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nexport class DES3 extends BlockCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._props = props;\r\n        const TripleDES = this._get3DES();\r\n        // Create DES instances\r\n        this._des1 = TripleDES[0];\r\n        this._des2 = TripleDES[1];\r\n        this._des3 = TripleDES[2];\r\n    }\r\n    _get3DES() {\r\n        // Shortcuts\r\n        const key = this._key;\r\n        const keyWords = key.words;\r\n        // Make sure the key length is valid (64, 128 or >= 192 bit)\r\n        if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\r\n            throw new Error(\"Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.\");\r\n        }\r\n        // Extend the key according to the keying options defined in 3DES standard\r\n        const key1 = keyWords.slice(0, 2);\r\n        const key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\r\n        const key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\r\n        // Create DES instances\r\n        const des1 = DES.createEncryptor(new Word32Array(key1));\r\n        const des2 = DES.createEncryptor(new Word32Array(key2));\r\n        const des3 = DES.createEncryptor(new Word32Array(key3));\r\n        return [des1, des2, des3];\r\n    }\r\n    _doReset() {\r\n        const TripleDES = this._get3DES();\r\n        // Create DES instances\r\n        this._des1 = TripleDES[0];\r\n        this._des2 = TripleDES[1];\r\n        this._des3 = TripleDES[2];\r\n    }\r\n    encryptBlock(words, offset) {\r\n        this._des1.encryptBlock(words, offset);\r\n        this._des2.decryptBlock(words, offset);\r\n        this._des3.encryptBlock(words, offset);\r\n    }\r\n    decryptBlock(words, offset) {\r\n        this._des3.decryptBlock(words, offset);\r\n        this._des2.encryptBlock(words, offset);\r\n        this._des1.decryptBlock(words, offset);\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.DES3.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new DES3(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.DES3.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new DES3(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.DES3.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(DES3, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(DES3, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.DES3.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(DES3, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(DES3, cipherText, key, props);\r\n    }\r\n}\r\nDES3.keySize = 192 / 32;\r\nDES3.ivSize = 64 / 32;\r\nDES3._blockSize = 64 / 32;\r\n","import { Utf8 } from \"./lib/encoder/Utf8\";\r\nexport class Hmac {\r\n    constructor(hasher, key) {\r\n        this._hasher = hasher;\r\n        // Convert string to WordArray, else assume WordArray already\r\n        if (typeof key == \"string\") {\r\n            key = Utf8.parse(key);\r\n        }\r\n        const hasherBlockSize = hasher.blockSize;\r\n        const hasherBlockSizeBytes = hasherBlockSize * 4;\r\n        // Allow arbitrary length keys\r\n        if (key.nSigBytes > hasherBlockSizeBytes) {\r\n            key = hasher.finalize(key);\r\n        }\r\n        // Clamp excess bits\r\n        key.clamp();\r\n        const oKey = this._oKey = key.clone();\r\n        const iKey = this._iKey = key.clone();\r\n        const oKeyWords = oKey.words;\r\n        const iKeyWords = iKey.words;\r\n        for (let i = 0; i < hasherBlockSize; i++) {\r\n            oKeyWords[i] ^= 0x5c5c5c5c;\r\n            iKeyWords[i] ^= 0x36363636;\r\n        }\r\n        iKey.nSigBytes = hasherBlockSizeBytes;\r\n        oKey.nSigBytes = hasherBlockSizeBytes;\r\n        // Set initial values\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets this Hmac to its initial state.\r\n     *\r\n     * @example\r\n     *   hmacHasher.reset();\r\n     */\r\n    reset() {\r\n        this._hasher.reset();\r\n        this._hasher.update(this._iKey);\r\n    }\r\n    /**\r\n     * Updates this Hmac with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hmac} This Hmac instance.\r\n     * @example\r\n     *   hmacHasher.update('message');\r\n     *   hmacHasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._hasher.update(messageUpdate);\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the Hmac computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The Hmac.\r\n     * @example\r\n     *   var hmac = hmacHasher.finalize();\r\n     *   var hmac = hmacHasher.finalize('message');\r\n     *   var hmac = hmacHasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        const innerHash = this._hasher.finalize(messageUpdate);\r\n        this._hasher.reset();\r\n        return this._hasher.finalize(this._oKey.clone().concat(innerHash));\r\n    }\r\n}\r\n","import { Hmac } from \"./Hmac\";\r\nimport { MD5 } from \"./MD5\";\r\nexport function HmacMD5(message, key) {\r\n    return new Hmac(new MD5(), key).finalize(message);\r\n}\r\n","import { Hmac } from \"./Hmac\";\r\nimport { SHA224 } from \"./SHA224\";\r\nexport function HmacSHA224(message, key) {\r\n    return new Hmac(new SHA224(), key).finalize(message);\r\n}\r\n","import { Hmac } from \"./Hmac\";\r\nimport { SHA256 } from \"./SHA256\";\r\nexport function HmacSHA256(message, key) {\r\n    return new Hmac(new SHA256(), key).finalize(message);\r\n}\r\n","import { Hmac } from \"./Hmac\";\r\nimport { SHA384 } from \"./SHA384\";\r\nexport function HmacSHA384(message, key) {\r\n    return new Hmac(new SHA384(), key).finalize(message);\r\n}\r\n","import { Hmac } from \"./Hmac\";\r\nimport { SHA512 } from \"./SHA512\";\r\nexport function HmacSHA512(message, key) {\r\n    return new Hmac(new SHA512(), key).finalize(message);\r\n}\r\n","import { Word32Array } from \"./lib/Word32Array\";\r\nimport { Hasher } from \"./lib/algorithm/Hasher\";\r\n// Constants table\r\nconst T = [];\r\n(function computeConstant() {\r\n    for (let i = 0; i < 64; i++) {\r\n        T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\r\n    }\r\n})();\r\nfunction FF(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & c) | (~b & d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction GG(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & d) | (c & ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction HH(a, b, c, d, x, s, t) {\r\n    const n = a + (b ^ c ^ d) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction II(a, b, c, d, x, s, t) {\r\n    const n = a + (c ^ (b | ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\n/**\r\n * MD5 hash algorithm\r\n */\r\nexport class MD5 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Swap endian\r\n        for (let i = 0; i < 16; i++) {\r\n            // Shortcuts\r\n            const offsetI = offset + i;\r\n            const wordsOffsetI = words[offsetI];\r\n            words[offsetI] = ((((wordsOffsetI << 8) | (wordsOffsetI >>> 24)) & 0x00ff00ff)\r\n                | (((wordsOffsetI << 24) | (wordsOffsetI >>> 8)) & 0xff00ff00));\r\n        }\r\n        // Shortcuts\r\n        const H = this._hash.words;\r\n        const wordOffset0 = words[offset];\r\n        const wordOffset1 = words[offset + 1];\r\n        const wordOffset2 = words[offset + 2];\r\n        const wordOffset3 = words[offset + 3];\r\n        const wordOffset4 = words[offset + 4];\r\n        const wordOffset5 = words[offset + 5];\r\n        const wordOffset6 = words[offset + 6];\r\n        const wordOffset7 = words[offset + 7];\r\n        const wordOffset8 = words[offset + 8];\r\n        const wordOffset9 = words[offset + 9];\r\n        const wordOffset10 = words[offset + 10];\r\n        const wordOffset11 = words[offset + 11];\r\n        const wordOffset12 = words[offset + 12];\r\n        const wordOffset13 = words[offset + 13];\r\n        const wordOffset14 = words[offset + 14];\r\n        const wordOffset15 = words[offset + 15];\r\n        // Working variables\r\n        let a = H[0];\r\n        let b = H[1];\r\n        let c = H[2];\r\n        let d = H[3];\r\n        // Computation\r\n        a = FF(a, b, c, d, wordOffset0, 7, T[0]);\r\n        d = FF(d, a, b, c, wordOffset1, 12, T[1]);\r\n        c = FF(c, d, a, b, wordOffset2, 17, T[2]);\r\n        b = FF(b, c, d, a, wordOffset3, 22, T[3]);\r\n        a = FF(a, b, c, d, wordOffset4, 7, T[4]);\r\n        d = FF(d, a, b, c, wordOffset5, 12, T[5]);\r\n        c = FF(c, d, a, b, wordOffset6, 17, T[6]);\r\n        b = FF(b, c, d, a, wordOffset7, 22, T[7]);\r\n        a = FF(a, b, c, d, wordOffset8, 7, T[8]);\r\n        d = FF(d, a, b, c, wordOffset9, 12, T[9]);\r\n        c = FF(c, d, a, b, wordOffset10, 17, T[10]);\r\n        b = FF(b, c, d, a, wordOffset11, 22, T[11]);\r\n        a = FF(a, b, c, d, wordOffset12, 7, T[12]);\r\n        d = FF(d, a, b, c, wordOffset13, 12, T[13]);\r\n        c = FF(c, d, a, b, wordOffset14, 17, T[14]);\r\n        b = FF(b, c, d, a, wordOffset15, 22, T[15]);\r\n        a = GG(a, b, c, d, wordOffset1, 5, T[16]);\r\n        d = GG(d, a, b, c, wordOffset6, 9, T[17]);\r\n        c = GG(c, d, a, b, wordOffset11, 14, T[18]);\r\n        b = GG(b, c, d, a, wordOffset0, 20, T[19]);\r\n        a = GG(a, b, c, d, wordOffset5, 5, T[20]);\r\n        d = GG(d, a, b, c, wordOffset10, 9, T[21]);\r\n        c = GG(c, d, a, b, wordOffset15, 14, T[22]);\r\n        b = GG(b, c, d, a, wordOffset4, 20, T[23]);\r\n        a = GG(a, b, c, d, wordOffset9, 5, T[24]);\r\n        d = GG(d, a, b, c, wordOffset14, 9, T[25]);\r\n        c = GG(c, d, a, b, wordOffset3, 14, T[26]);\r\n        b = GG(b, c, d, a, wordOffset8, 20, T[27]);\r\n        a = GG(a, b, c, d, wordOffset13, 5, T[28]);\r\n        d = GG(d, a, b, c, wordOffset2, 9, T[29]);\r\n        c = GG(c, d, a, b, wordOffset7, 14, T[30]);\r\n        b = GG(b, c, d, a, wordOffset12, 20, T[31]);\r\n        a = HH(a, b, c, d, wordOffset5, 4, T[32]);\r\n        d = HH(d, a, b, c, wordOffset8, 11, T[33]);\r\n        c = HH(c, d, a, b, wordOffset11, 16, T[34]);\r\n        b = HH(b, c, d, a, wordOffset14, 23, T[35]);\r\n        a = HH(a, b, c, d, wordOffset1, 4, T[36]);\r\n        d = HH(d, a, b, c, wordOffset4, 11, T[37]);\r\n        c = HH(c, d, a, b, wordOffset7, 16, T[38]);\r\n        b = HH(b, c, d, a, wordOffset10, 23, T[39]);\r\n        a = HH(a, b, c, d, wordOffset13, 4, T[40]);\r\n        d = HH(d, a, b, c, wordOffset0, 11, T[41]);\r\n        c = HH(c, d, a, b, wordOffset3, 16, T[42]);\r\n        b = HH(b, c, d, a, wordOffset6, 23, T[43]);\r\n        a = HH(a, b, c, d, wordOffset9, 4, T[44]);\r\n        d = HH(d, a, b, c, wordOffset12, 11, T[45]);\r\n        c = HH(c, d, a, b, wordOffset15, 16, T[46]);\r\n        b = HH(b, c, d, a, wordOffset2, 23, T[47]);\r\n        a = II(a, b, c, d, wordOffset0, 6, T[48]);\r\n        d = II(d, a, b, c, wordOffset7, 10, T[49]);\r\n        c = II(c, d, a, b, wordOffset14, 15, T[50]);\r\n        b = II(b, c, d, a, wordOffset5, 21, T[51]);\r\n        a = II(a, b, c, d, wordOffset12, 6, T[52]);\r\n        d = II(d, a, b, c, wordOffset3, 10, T[53]);\r\n        c = II(c, d, a, b, wordOffset10, 15, T[54]);\r\n        b = II(b, c, d, a, wordOffset1, 21, T[55]);\r\n        a = II(a, b, c, d, wordOffset8, 6, T[56]);\r\n        d = II(d, a, b, c, wordOffset15, 10, T[57]);\r\n        c = II(c, d, a, b, wordOffset6, 15, T[58]);\r\n        b = II(b, c, d, a, wordOffset13, 21, T[59]);\r\n        a = II(a, b, c, d, wordOffset4, 6, T[60]);\r\n        d = II(d, a, b, c, wordOffset11, 10, T[61]);\r\n        c = II(c, d, a, b, wordOffset2, 15, T[62]);\r\n        b = II(b, c, d, a, wordOffset9, 21, T[63]);\r\n        // Intermediate hash value\r\n        H[0] = (H[0] + a) | 0;\r\n        H[1] = (H[1] + b) | 0;\r\n        H[2] = (H[2] + c) | 0;\r\n        H[3] = (H[3] + d) | 0;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\r\n        const nBitsTotalL = nBitsTotal;\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));\r\n        data.nSigBytes = (dataWords.length + 1) * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Shortcuts\r\n        const hash = this._hash;\r\n        const H = hash.words;\r\n        // Swap endian\r\n        for (let i = 0; i < 4; i++) {\r\n            // Shortcut\r\n            const Hi = H[i];\r\n            H[i] = (((Hi << 8) | (Hi >>> 24)) & 0x00ff00ff)\r\n                | (((Hi << 24) | (Hi >>> 8)) & 0xff00ff00);\r\n        }\r\n        // Return final computed hash\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new MD5(props);\r\n    }\r\n    static hash(message) {\r\n        return new MD5().finalize(message);\r\n    }\r\n}\r\n","import { StreamCipher } from \"./lib/algorithm/cipher/StreamCipher\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nexport class RC4 extends StreamCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this.S = [];\r\n        this.i = 0;\r\n        this.j = 0;\r\n        this._props = props;\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        // Shortcuts\r\n        const key = this._key;\r\n        const keyWords = key.words;\r\n        const keySigBytes = key.nSigBytes;\r\n        // Init sbox\r\n        this.S = [];\r\n        for (let i = 0; i < 256; i++) {\r\n            this.S[i] = i;\r\n        }\r\n        // Key setup\r\n        for (let i = 0, j = 0; i < 256; i++) {\r\n            const keyByteIndex = i % keySigBytes;\r\n            const keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\r\n            j = (j + this.S[i] + keyByte) % 256;\r\n            // Swap\r\n            const t = this.S[i];\r\n            this.S[i] = this.S[j];\r\n            this.S[j] = t;\r\n        }\r\n        // Counters\r\n        this.i = this.j = 0;\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        words[offset] ^= this.generateKeyStreamWord();\r\n    }\r\n    generateKeyStreamWord() {\r\n        // Shortcuts\r\n        const S = this.S;\r\n        let i = this.i;\r\n        let j = this.j;\r\n        // Generate keyStream word\r\n        let keyStreamWord = 0;\r\n        for (let n = 0; n < 4; n++) {\r\n            i = (i + 1) % 256;\r\n            j = (j + S[i]) % 256;\r\n            // Swap\r\n            const t = S[i];\r\n            S[i] = S[j];\r\n            S[j] = t;\r\n            keyStreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\r\n        }\r\n        // Update counters\r\n        this.i = i;\r\n        this.j = j;\r\n        return keyStreamWord;\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4.createEncryptor(keyWordArray);\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(RC4, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(RC4, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(RC4, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(RC4, cipherText, key, props);\r\n    }\r\n}\r\nRC4.ivSize = 0;\r\nRC4.keySize = 256 / 32;\r\n","import { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nimport { RC4 } from \"./RC4\";\r\nexport class RC4Drop extends RC4 {\r\n    constructor(props) {\r\n        super(props);\r\n        this.drop = 192;\r\n        this._props = props;\r\n        if (props && typeof props.drop === \"number\") {\r\n            this.drop = props.drop;\r\n        }\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        super._doReset();\r\n        // Drop\r\n        for (let i = this.drop; i > 0; i--) {\r\n            this.generateKeyStreamWord();\r\n        }\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4Drop.createEncryptor(keyWordArray);\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4Drop(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4Drop.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4Drop(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4Drop.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(RC4Drop, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(RC4Drop, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4Drop.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(RC4Drop, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(RC4Drop, cipherText, key, props);\r\n    }\r\n}\r\n","/** @preserve\r\n(c) 2012 by Cdric Mesnil. All rights reserved.\r\nRedistribution and use in source and binary forms, with or without modification,\r\n are permitted provided that the following conditions are met:\r\n \r\n- Redistributions of source code must retain the above copyright notice,\r\n  this list of conditions and the following disclaimer.\r\n- Redistributions in binary form must reproduce the above copyright notice,\r\n  this list of conditions and the following disclaimer in the documentation\r\n  and/or other materials provided with the distribution.\r\n \r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\r\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\nIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\n// Constants table\r\nconst _zl = new Word32Array([\r\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\r\n    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\r\n    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\r\n    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\r\n]);\r\nconst _zr = new Word32Array([\r\n    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\r\n    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\r\n    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\r\n    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\r\n    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\r\n]);\r\nconst _sl = new Word32Array([\r\n    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\r\n    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\r\n    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\r\n    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\r\n    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\r\n]);\r\nconst _sr = new Word32Array([\r\n    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\r\n    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\r\n    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\r\n    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\r\n    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\r\n]);\r\nconst _hl = new Word32Array([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\r\nconst _hr = new Word32Array([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\r\nfunction f1(x, y, z) {\r\n    return ((x) ^ (y) ^ (z));\r\n}\r\nfunction f2(x, y, z) {\r\n    return (((x) & (y)) | ((~x) & (z)));\r\n}\r\nfunction f3(x, y, z) {\r\n    return (((x) | (~(y))) ^ (z));\r\n}\r\nfunction f4(x, y, z) {\r\n    return (((x) & (z)) | ((y) & (~(z))));\r\n}\r\nfunction f5(x, y, z) {\r\n    return ((x) ^ ((y) | (~(z))));\r\n}\r\nfunction rotl(x, n) {\r\n    return (x << n) | (x >>> (32 - n));\r\n}\r\nexport class RIPEMD160 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Swap endian\r\n        for (let i = 0; i < 16; i++) {\r\n            // Shortcuts\r\n            const offsetI = offset + i;\r\n            const wordsOffsetI = words[offsetI];\r\n            // Swap\r\n            words[offsetI] = ((((wordsOffsetI << 8) | (wordsOffsetI >>> 24)) & 0x00ff00ff) |\r\n                (((wordsOffsetI << 24) | (wordsOffsetI >>> 8)) & 0xff00ff00));\r\n        }\r\n        // Shortcut\r\n        const H = this._hash.words;\r\n        const hl = _hl.words;\r\n        const hr = _hr.words;\r\n        const zl = _zl.words;\r\n        const zr = _zr.words;\r\n        const sl = _sl.words;\r\n        const sr = _sr.words;\r\n        // Working variables\r\n        let al;\r\n        let bl;\r\n        let cl;\r\n        let dl;\r\n        let el;\r\n        let ar;\r\n        let br;\r\n        let cr;\r\n        let dr;\r\n        let er;\r\n        ar = al = H[0];\r\n        br = bl = H[1];\r\n        cr = cl = H[2];\r\n        dr = dl = H[3];\r\n        er = el = H[4];\r\n        // Computation\r\n        let t;\r\n        for (let i = 0; i < 80; i += 1) {\r\n            t = (al + words[offset + zl[i]]) | 0;\r\n            if (i < 16) {\r\n                t += f1(bl, cl, dl) + hl[0];\r\n            }\r\n            else if (i < 32) {\r\n                t += f2(bl, cl, dl) + hl[1];\r\n            }\r\n            else if (i < 48) {\r\n                t += f3(bl, cl, dl) + hl[2];\r\n            }\r\n            else if (i < 64) {\r\n                t += f4(bl, cl, dl) + hl[3];\r\n            }\r\n            else { // if (i<80) {\r\n                t += f5(bl, cl, dl) + hl[4];\r\n            }\r\n            t = t | 0;\r\n            t = rotl(t, sl[i]);\r\n            t = (t + el) | 0;\r\n            al = el;\r\n            el = dl;\r\n            dl = rotl(cl, 10);\r\n            cl = bl;\r\n            bl = t;\r\n            t = (ar + words[offset + zr[i]]) | 0;\r\n            if (i < 16) {\r\n                t += f5(br, cr, dr) + hr[0];\r\n            }\r\n            else if (i < 32) {\r\n                t += f4(br, cr, dr) + hr[1];\r\n            }\r\n            else if (i < 48) {\r\n                t += f3(br, cr, dr) + hr[2];\r\n            }\r\n            else if (i < 64) {\r\n                t += f2(br, cr, dr) + hr[3];\r\n            }\r\n            else { // if (i<80) {\r\n                t += f1(br, cr, dr) + hr[4];\r\n            }\r\n            t = t | 0;\r\n            t = rotl(t, sr[i]);\r\n            t = (t + er) | 0;\r\n            ar = er;\r\n            er = dr;\r\n            dr = rotl(cr, 10);\r\n            cr = br;\r\n            br = t;\r\n        }\r\n        // Intermediate hash value\r\n        t = (H[1] + cl + dr) | 0;\r\n        H[1] = (H[2] + dl + er) | 0;\r\n        H[2] = (H[3] + el + ar) | 0;\r\n        H[3] = (H[4] + al + br) | 0;\r\n        H[4] = (H[0] + bl + cr) | 0;\r\n        H[0] = t;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));\r\n        data.nSigBytes = (dataWords.length + 1) * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Shortcuts\r\n        const hash = this._hash;\r\n        const H = hash.words;\r\n        // Swap endian\r\n        for (let i = 0; i < 5; i++) {\r\n            // Shortcut\r\n            const Hi = H[i];\r\n            // Swap\r\n            H[i] = (((Hi << 8) | (Hi >>> 24)) & 0x00ff00ff) |\r\n                (((Hi << 24) | (Hi >>> 8)) & 0xff00ff00);\r\n        }\r\n        // Return final computed hash\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new RIPEMD160(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new RIPEMD160(props).finalize(message);\r\n    }\r\n}\r\n","import { StreamCipher } from \"./lib/algorithm/cipher/StreamCipher\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nexport class Rabbit extends StreamCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 128 / 32;\r\n        this.S = [];\r\n        this.C = [];\r\n        this.G = [];\r\n        this._X = [];\r\n        this._C = [];\r\n        this._b = 0;\r\n        this._props = props;\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        // Shortcuts\r\n        const K = this._key.words;\r\n        const iv = this._iv;\r\n        // Swap endian\r\n        for (let i = 0; i < 4; i++) {\r\n            K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff)\r\n                | (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);\r\n        }\r\n        // Generate initial state values\r\n        const X = this._X = [\r\n            K[0], (K[3] << 16) | (K[2] >>> 16),\r\n            K[1], (K[0] << 16) | (K[3] >>> 16),\r\n            K[2], (K[1] << 16) | (K[0] >>> 16),\r\n            K[3], (K[2] << 16) | (K[1] >>> 16)\r\n        ];\r\n        // Generate initial counter values\r\n        const C = this._C = [\r\n            (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\r\n            (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\r\n            (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\r\n            (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\r\n        ];\r\n        // Carry bit\r\n        this._b = 0;\r\n        // Iterate the system four times\r\n        for (let i = 0; i < 4; i++) {\r\n            this.nextState();\r\n        }\r\n        // Modify the counters\r\n        for (let i = 0; i < 8; i++) {\r\n            C[i] ^= X[(i + 4) & 7];\r\n        }\r\n        // IV setup\r\n        if (!iv) {\r\n            return;\r\n        }\r\n        // Shortcuts\r\n        const IV = iv.words;\r\n        const IV_0 = IV[0];\r\n        const IV_1 = IV[1];\r\n        // Generate four sub vectors\r\n        const i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\r\n        const i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\r\n        const i1 = (i0 >>> 16) | (i2 & 0xffff0000);\r\n        const i3 = (i2 << 16) | (i0 & 0x0000ffff);\r\n        // Modify counter values\r\n        C[0] ^= i0;\r\n        C[1] ^= i1;\r\n        C[2] ^= i2;\r\n        C[3] ^= i3;\r\n        C[4] ^= i0;\r\n        C[5] ^= i1;\r\n        C[6] ^= i2;\r\n        C[7] ^= i3;\r\n        // Iterate the system four times\r\n        for (let i = 0; i < 4; i++) {\r\n            this.nextState();\r\n        }\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Shortcut\r\n        const X = this._X;\r\n        // Iterate the system\r\n        this.nextState();\r\n        // Generate four key stream words\r\n        this.S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\r\n        this.S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\r\n        this.S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\r\n        this.S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\r\n        for (let i = 0; i < 4; i++) {\r\n            // Swap endian\r\n            this.S[i] = (((this.S[i] << 8) | (this.S[i] >>> 24)) & 0x00ff00ff) |\r\n                (((this.S[i] << 24) | (this.S[i] >>> 8)) & 0xff00ff00);\r\n            // Encrypt\r\n            words[offset + i] ^= this.S[i];\r\n        }\r\n    }\r\n    nextState() {\r\n        // Shortcuts\r\n        const X = this._X;\r\n        const C = this._C;\r\n        // Save old counter values\r\n        for (let i = 0; i < 8; i++) {\r\n            this.C[i] = C[i];\r\n        }\r\n        // Calculate new counter values\r\n        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\r\n        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (this.C[0] >>> 0) ? 1 : 0)) | 0;\r\n        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (this.C[1] >>> 0) ? 1 : 0)) | 0;\r\n        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (this.C[2] >>> 0) ? 1 : 0)) | 0;\r\n        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (this.C[3] >>> 0) ? 1 : 0)) | 0;\r\n        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (this.C[4] >>> 0) ? 1 : 0)) | 0;\r\n        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (this.C[5] >>> 0) ? 1 : 0)) | 0;\r\n        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (this.C[6] >>> 0) ? 1 : 0)) | 0;\r\n        this._b = (C[7] >>> 0) < (this.C[7] >>> 0) ? 1 : 0;\r\n        // Calculate the g-values\r\n        for (let i = 0; i < 8; i++) {\r\n            const gx = X[i] + C[i];\r\n            // Construct high and low argument for squaring\r\n            const ga = gx & 0xffff;\r\n            const gb = gx >>> 16;\r\n            // Calculate high and low result of squaring\r\n            const gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\r\n            const gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\r\n            // High XOR low\r\n            this.G[i] = gh ^ gl;\r\n        }\r\n        const G = this.G;\r\n        // Calculate new state values\r\n        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\r\n        X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;\r\n        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\r\n        X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;\r\n        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\r\n        X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;\r\n        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\r\n        X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.Rabbit.createEncryptor(keyWordArray);\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Rabbit(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.Rabbit.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Rabbit(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.Rabbit.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(Rabbit, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(Rabbit, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.Rabbit.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(Rabbit, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(Rabbit, cipherText, key, props);\r\n    }\r\n}\r\nRabbit.ivSize = 128 / 32;\r\n","import { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\n// Reusable object\r\nconst W = [];\r\nexport class SHA1 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476,\r\n            0xc3d2e1f0\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476,\r\n            0xc3d2e1f0\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        const H = this._hash.words;\r\n        // Working variables\r\n        let a = H[0];\r\n        let b = H[1];\r\n        let c = H[2];\r\n        let d = H[3];\r\n        let e = H[4];\r\n        // Computation\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 16) {\r\n                W[i] = words[offset + i] | 0;\r\n            }\r\n            else {\r\n                const n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n                W[i] = (n << 1) | (n >>> 31);\r\n            }\r\n            let t = ((a << 5) | (a >>> 27)) + e + W[i];\r\n            if (i < 20) {\r\n                t += ((b & c) | (~b & d)) + 0x5a827999;\r\n            }\r\n            else if (i < 40) {\r\n                t += (b ^ c ^ d) + 0x6ed9eba1;\r\n            }\r\n            else if (i < 60) {\r\n                t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\r\n            }\r\n            else /* if (i < 80) */ {\r\n                t += (b ^ c ^ d) - 0x359d3e2a;\r\n            }\r\n            e = d;\r\n            d = c;\r\n            c = (b << 30) | (b >>> 2);\r\n            b = a;\r\n            a = t;\r\n        }\r\n        // Intermediate hash value\r\n        H[0] = (H[0] + a) | 0;\r\n        H[1] = (H[1] + b) | 0;\r\n        H[2] = (H[2] + c) | 0;\r\n        H[3] = (H[3] + d) | 0;\r\n        H[4] = (H[4] + e) | 0;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const dataWords = this._data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = this._data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\r\n        this._data.nSigBytes = dataWords.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Return final computed hash\r\n        return this._hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA1(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA1(props).finalize(message);\r\n    }\r\n}\r\n","import { Word32Array } from \"./lib/Word32Array\";\r\nimport { SHA256 } from \"./SHA256\";\r\nexport class SHA224 extends SHA256 {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\r\n            0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\r\n            0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\r\n        ]);\r\n    }\r\n    _doFinalize() {\r\n        const hash = super._doFinalize.call(this);\r\n        hash.nSigBytes -= 4;\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA224(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA224(props).finalize(message);\r\n    }\r\n}\r\n","import { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\n// Hash values\r\nconst H = [];\r\n// Round constants\r\nconst K = [];\r\nfunction isPrime(n) {\r\n    const sqrtN = Math.sqrt(n);\r\n    for (let factor = 2; factor <= sqrtN; factor++) {\r\n        if (!(n % factor)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getFractionalBits(n) {\r\n    return ((n - (n | 0)) * 0x100000000) | 0;\r\n}\r\n(function computeRoundConstants() {\r\n    let n = 2;\r\n    let nPrime = 0;\r\n    while (nPrime < 64) {\r\n        if (isPrime(n)) {\r\n            if (nPrime < 8) {\r\n                H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\r\n            }\r\n            K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\r\n            nPrime++;\r\n        }\r\n        n++;\r\n    }\r\n})();\r\n// Reusable object\r\nconst W = [];\r\nexport class SHA256 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array(H.slice(0));\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array(H.slice(0));\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        const _H = this._hash.words;\r\n        let a = _H[0];\r\n        let b = _H[1];\r\n        let c = _H[2];\r\n        let d = _H[3];\r\n        let e = _H[4];\r\n        let f = _H[5];\r\n        let g = _H[6];\r\n        let h = _H[7];\r\n        for (let i = 0; i < 64; i++) {\r\n            if (i < 16) {\r\n                W[i] = words[offset + i] | 0;\r\n            }\r\n            else {\r\n                const gamma0x = W[i - 15];\r\n                const gamma0 = ((gamma0x << 25) | (gamma0x >>> 7))\r\n                    ^ ((gamma0x << 14) | (gamma0x >>> 18))\r\n                    ^ (gamma0x >>> 3);\r\n                const gamma1x = W[i - 2];\r\n                const gamma1 = ((gamma1x << 15) | (gamma1x >>> 17))\r\n                    ^ ((gamma1x << 13) | (gamma1x >>> 19))\r\n                    ^ (gamma1x >>> 10);\r\n                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\r\n            }\r\n            const ch = (e & f) ^ (~e & g);\r\n            const maj = (a & b) ^ (a & c) ^ (b & c);\r\n            const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\r\n            const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\r\n            const t1 = h + sigma1 + ch + K[i] + W[i];\r\n            const t2 = sigma0 + maj;\r\n            h = g;\r\n            g = f;\r\n            f = e;\r\n            e = (d + t1) | 0;\r\n            d = c;\r\n            c = b;\r\n            b = a;\r\n            a = (t1 + t2) | 0;\r\n        }\r\n        // Intermediate hash value\r\n        _H[0] = (_H[0] + a) | 0;\r\n        _H[1] = (_H[1] + b) | 0;\r\n        _H[2] = (_H[2] + c) | 0;\r\n        _H[3] = (_H[3] + d) | 0;\r\n        _H[4] = (_H[4] + e) | 0;\r\n        _H[5] = (_H[5] + f) | 0;\r\n        _H[6] = (_H[6] + g) | 0;\r\n        _H[7] = (_H[7] + h) | 0;\r\n    }\r\n    _doFinalize() {\r\n        const words = this._data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = this._data.nSigBytes * 8;\r\n        // Add padding\r\n        words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\r\n        words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\r\n        this._data.nSigBytes = words.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Return final computed hash\r\n        return this._hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA256(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA256(props).finalize(message);\r\n    }\r\n}\r\n","// Constants tables\r\nimport { Word64 } from \"./lib/Word64Array\";\r\nimport { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\nconst RHO_OFFSETS = [];\r\nconst PI_INDEXES = [];\r\nconst ROUND_CONSTANTS = [];\r\n// Compute Constants\r\n(function computeConstants() {\r\n    // Compute rho offset constants\r\n    let x = 1;\r\n    let y = 0;\r\n    for (let t = 0; t < 24; t++) {\r\n        RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\r\n        const newX = y % 5;\r\n        const newY = (2 * x + 3 * y) % 5;\r\n        x = newX;\r\n        y = newY;\r\n    }\r\n    // Compute pi index constants\r\n    for (let p = 0; p < 5; p++) {\r\n        for (let q = 0; q < 5; q++) {\r\n            PI_INDEXES[p + 5 * q] = q + ((2 * p + 3 * q) % 5) * 5;\r\n        }\r\n    }\r\n    // Compute round constants\r\n    let LFSR = 0x01;\r\n    for (let i = 0; i < 24; i++) {\r\n        let roundConstantMsw = 0;\r\n        let roundConstantLsw = 0;\r\n        for (let j = 0; j < 7; j++) {\r\n            if (LFSR & 0x01) {\r\n                const bitPosition = (1 << j) - 1;\r\n                if (bitPosition < 32) {\r\n                    roundConstantLsw ^= 1 << bitPosition;\r\n                }\r\n                else /* if (bitPosition >= 32) */ {\r\n                    roundConstantMsw ^= 1 << (bitPosition - 32);\r\n                }\r\n            }\r\n            // Compute next LFSR\r\n            if (LFSR & 0x80) {\r\n                // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\r\n                LFSR = (LFSR << 1) ^ 0x71;\r\n            }\r\n            else {\r\n                LFSR <<= 1;\r\n            }\r\n        }\r\n        ROUND_CONSTANTS[i] = new Word64(roundConstantMsw, roundConstantLsw);\r\n    }\r\n}());\r\n// Reusable objects for temporary values\r\nconst T = [];\r\n(function () {\r\n    for (let i = 0; i < 25; i++) {\r\n        T[i] = new Word64(0, 0);\r\n    }\r\n}());\r\nexport class SHA3 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 1024 / 32;\r\n        this._state = [];\r\n        this._outputLength = 512;\r\n        this._props = props;\r\n        if (props) {\r\n            if (typeof props.outputLength !== \"undefined\") {\r\n                if (![224, 256, 384, 512].includes(props.outputLength)) {\r\n                    throw new Error(\"Unsupported output length.\");\r\n                }\r\n                this._outputLength = props.outputLength;\r\n            }\r\n            if (typeof props.state !== \"undefined\") {\r\n                this._state = props.state.map(s => s.clone());\r\n            }\r\n        }\r\n        if (this._state.length === 0) {\r\n            for (let i = 0; i < 25; i++) {\r\n                this._state[i] = new Word64(0, 0);\r\n            }\r\n        }\r\n        this._blockSize = (1600 - 2 * this._outputLength) / 32;\r\n    }\r\n    _doReset() {\r\n        this._state = [];\r\n        for (let i = 0; i < 25; i++) {\r\n            this._state[i] = new Word64(0, 0);\r\n        }\r\n        this._blockSize = (1600 - 2 * this._outputLength) / 32;\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Shortcuts\r\n        const state = this._state;\r\n        const nBlockSizeLanes = this._blockSize / 2;\r\n        // Absorb\r\n        for (let i = 0; i < nBlockSizeLanes; i++) {\r\n            // Shortcuts\r\n            let W2i = words[offset + 2 * i];\r\n            let W2i1 = words[offset + 2 * i + 1];\r\n            // Swap endian\r\n            W2i = ((((W2i << 8) | (W2i >>> 24)) & 0x00ff00ff) |\r\n                (((W2i << 24) | (W2i >>> 8)) & 0xff00ff00));\r\n            W2i1 = ((((W2i1 << 8) | (W2i1 >>> 24)) & 0x00ff00ff) |\r\n                (((W2i1 << 24) | (W2i1 >>> 8)) & 0xff00ff00));\r\n            // Absorb message into state\r\n            state[i].high ^= W2i1;\r\n            state[i].low ^= W2i;\r\n        }\r\n        // Rounds\r\n        for (let round = 0; round < 24; round++) {\r\n            // Theta\r\n            for (let x = 0; x < 5; x++) {\r\n                // Mix column lanes\r\n                let tMsw = 0;\r\n                let tLsw = 0;\r\n                for (let y = 0; y < 5; y++) {\r\n                    const l = state[x + 5 * y];\r\n                    tMsw ^= l.high;\r\n                    tLsw ^= l.low;\r\n                }\r\n                // Temporary values\r\n                const Tx = T[x];\r\n                Tx.high = tMsw;\r\n                Tx.low = tLsw;\r\n            }\r\n            for (let x = 0; x < 5; x++) {\r\n                // Shortcuts\r\n                const Tx4 = T[(x + 4) % 5];\r\n                const Tx1 = T[(x + 1) % 5];\r\n                const Tx1Msw = Tx1.high;\r\n                const Tx1Lsw = Tx1.low;\r\n                // Mix surrounding columns\r\n                const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\r\n                const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\r\n                for (let y = 0; y < 5; y++) {\r\n                    const l = state[x + 5 * y];\r\n                    l.high ^= tMsw;\r\n                    l.low ^= tLsw;\r\n                }\r\n            }\r\n            // Rho Pi\r\n            for (let laneIndex = 1; laneIndex < 25; laneIndex++) {\r\n                let tMsw;\r\n                let tLsw;\r\n                // Shortcuts\r\n                const laneMsw = state[laneIndex].high;\r\n                const laneLsw = state[laneIndex].low;\r\n                const rhoOffset = RHO_OFFSETS[laneIndex];\r\n                // Rotate lanes\r\n                if (rhoOffset < 32) {\r\n                    tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\r\n                    tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\r\n                }\r\n                else /* if (rhoOffset >= 32) */ {\r\n                    tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\r\n                    tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\r\n                }\r\n                // Transpose lanes\r\n                const TPiLane = T[PI_INDEXES[laneIndex]];\r\n                TPiLane.high = tMsw;\r\n                TPiLane.low = tLsw;\r\n            }\r\n            // Rho pi at x = y = 0\r\n            const T0 = T[0];\r\n            const state0 = state[0];\r\n            T0.high = state0.high;\r\n            T0.low = state0.low;\r\n            // Chi\r\n            for (let x = 0; x < 5; x++) {\r\n                for (let y = 0; y < 5; y++) {\r\n                    // Shortcuts\r\n                    const laneIndex = x + 5 * y;\r\n                    const l = state[laneIndex];\r\n                    const TLane = T[laneIndex];\r\n                    const Tx1Lane = T[((x + 1) % 5) + 5 * y];\r\n                    const Tx2Lane = T[((x + 2) % 5) + 5 * y];\r\n                    // Mix rows\r\n                    l.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\r\n                    l.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\r\n                }\r\n            }\r\n            // Iota\r\n            const lane = state[0];\r\n            const roundConstant = ROUND_CONSTANTS[round];\r\n            lane.high ^= roundConstant.high;\r\n            lane.low ^= roundConstant.low;\r\n        }\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        const blockSizeBits = this.blockSize * 32;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\r\n        dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\r\n        data.nSigBytes = dataWords.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Shortcuts\r\n        const state = this._state;\r\n        const outputLengthBytes = this._outputLength / 8;\r\n        const outputLengthLanes = outputLengthBytes / 8;\r\n        // Squeeze\r\n        const hashWords = [];\r\n        for (let i = 0; i < outputLengthLanes; i++) {\r\n            // Shortcuts\r\n            const lane = state[i];\r\n            let laneMsw = lane.high;\r\n            let laneLsw = lane.low;\r\n            // Swap endian\r\n            laneMsw = ((((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) |\r\n                (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00));\r\n            laneLsw = ((((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) |\r\n                (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00));\r\n            // Squeeze state to retrieve hash\r\n            hashWords.push(laneLsw);\r\n            hashWords.push(laneMsw);\r\n        }\r\n        // Return final computed hash\r\n        return new Word32Array(hashWords, outputLengthBytes);\r\n    }\r\n    clone() {\r\n        const props = {\r\n            outputLength: this._outputLength,\r\n            state: this._state,\r\n            blockSize: this._blockSize,\r\n            data: this._data,\r\n            nBytes: this._nBytes,\r\n        };\r\n        return new SHA3(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA3(props).finalize(message);\r\n    }\r\n}\r\n","import { Word64, Word64Array } from \"./lib/Word64Array\";\r\nimport { SHA512 } from \"./SHA512\";\r\nexport class SHA384 extends SHA512 {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word64Array([\r\n            new Word64(0xcbbb9d5d, 0xc1059ed8), new Word64(0x629a292a, 0x367cd507),\r\n            new Word64(0x9159015a, 0x3070dd17), new Word64(0x152fecd8, 0xf70e5939),\r\n            new Word64(0x67332667, 0xffc00b31), new Word64(0x8eb44a87, 0x68581511),\r\n            new Word64(0xdb0c2e0d, 0x64f98fa7), new Word64(0x47b5481d, 0xbefa4fa4)\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word64Array([\r\n            new Word64(0xcbbb9d5d, 0xc1059ed8), new Word64(0x629a292a, 0x367cd507),\r\n            new Word64(0x9159015a, 0x3070dd17), new Word64(0x152fecd8, 0xf70e5939),\r\n            new Word64(0x67332667, 0xffc00b31), new Word64(0x8eb44a87, 0x68581511),\r\n            new Word64(0xdb0c2e0d, 0x64f98fa7), new Word64(0x47b5481d, 0xbefa4fa4)\r\n        ]);\r\n    }\r\n    _doFinalize() {\r\n        const hash = super._doFinalize.call(this);\r\n        hash.nSigBytes -= 16;\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA384(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA384(props).finalize(message);\r\n    }\r\n}\r\n","import { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word64, Word64Array } from \"./lib/Word64Array\";\r\nconst K = [\r\n    new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd),\r\n    new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc),\r\n    new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019),\r\n    new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118),\r\n    new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe),\r\n    new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2),\r\n    new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1),\r\n    new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694),\r\n    new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3),\r\n    new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65),\r\n    new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483),\r\n    new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5),\r\n    new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210),\r\n    new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4),\r\n    new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725),\r\n    new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70),\r\n    new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926),\r\n    new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df),\r\n    new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8),\r\n    new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b),\r\n    new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001),\r\n    new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30),\r\n    new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910),\r\n    new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8),\r\n    new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53),\r\n    new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8),\r\n    new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb),\r\n    new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3),\r\n    new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60),\r\n    new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec),\r\n    new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9),\r\n    new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b),\r\n    new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207),\r\n    new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178),\r\n    new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6),\r\n    new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b),\r\n    new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493),\r\n    new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c),\r\n    new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a),\r\n    new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817),\r\n];\r\nconst W = [];\r\n(function computeConstants() {\r\n    for (let i = 0; i < 80; i++) {\r\n        W[i] = new Word64(0, 0);\r\n    }\r\n})();\r\nexport class SHA512 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 1024 / 32;\r\n        this._hash = new Word64Array([\r\n            new Word64(0x6a09e667, 0xf3bcc908), new Word64(0xbb67ae85, 0x84caa73b),\r\n            new Word64(0x3c6ef372, 0xfe94f82b), new Word64(0xa54ff53a, 0x5f1d36f1),\r\n            new Word64(0x510e527f, 0xade682d1), new Word64(0x9b05688c, 0x2b3e6c1f),\r\n            new Word64(0x1f83d9ab, 0xfb41bd6b), new Word64(0x5be0cd19, 0x137e2179)\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word64Array([\r\n            new Word64(0x6a09e667, 0xf3bcc908), new Word64(0xbb67ae85, 0x84caa73b),\r\n            new Word64(0x3c6ef372, 0xfe94f82b), new Word64(0xa54ff53a, 0x5f1d36f1),\r\n            new Word64(0x510e527f, 0xade682d1), new Word64(0x9b05688c, 0x2b3e6c1f),\r\n            new Word64(0x1f83d9ab, 0xfb41bd6b), new Word64(0x5be0cd19, 0x137e2179)\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Shortcuts\r\n        const H = this._hash.words;\r\n        const H0 = H[0];\r\n        const H1 = H[1];\r\n        const H2 = H[2];\r\n        const H3 = H[3];\r\n        const H4 = H[4];\r\n        const H5 = H[5];\r\n        const H6 = H[6];\r\n        const H7 = H[7];\r\n        const H0h = H0.high;\r\n        let H0l = H0.low;\r\n        const H1h = H1.high;\r\n        let H1l = H1.low;\r\n        const H2h = H2.high;\r\n        let H2l = H2.low;\r\n        const H3h = H3.high;\r\n        let H3l = H3.low;\r\n        const H4h = H4.high;\r\n        let H4l = H4.low;\r\n        const H5h = H5.high;\r\n        let H5l = H5.low;\r\n        const H6h = H6.high;\r\n        let H6l = H6.low;\r\n        const H7h = H7.high;\r\n        let H7l = H7.low;\r\n        // Working variables\r\n        let ah = H0h;\r\n        let al = H0l;\r\n        let bh = H1h;\r\n        let bl = H1l;\r\n        let ch = H2h;\r\n        let cl = H2l;\r\n        let dh = H3h;\r\n        let dl = H3l;\r\n        let eh = H4h;\r\n        let el = H4l;\r\n        let fh = H5h;\r\n        let fl = H5l;\r\n        let gh = H6h;\r\n        let gl = H6l;\r\n        let hh = H7h;\r\n        let hl = H7l;\r\n        // Rounds\r\n        for (let i = 0; i < 80; i++) {\r\n            let Wil;\r\n            let Wih;\r\n            // Shortcut\r\n            const Wi = W[i];\r\n            // Extend message\r\n            if (i < 16) {\r\n                Wih = Wi.high = words[offset + i * 2] | 0;\r\n                Wil = Wi.low = words[offset + i * 2 + 1] | 0;\r\n            }\r\n            else {\r\n                // Gamma0\r\n                const gamma0x = W[i - 15];\r\n                const gamma0xh = gamma0x.high;\r\n                const gamma0xl = gamma0x.low;\r\n                const gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31))\r\n                    ^ ((gamma0xh >>> 8) | (gamma0xl << 24))\r\n                    ^ (gamma0xh >>> 7);\r\n                const gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31))\r\n                    ^ ((gamma0xl >>> 8) | (gamma0xh << 24))\r\n                    ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\r\n                // Gamma1\r\n                const gamma1x = W[i - 2];\r\n                const gamma1xh = gamma1x.high;\r\n                const gamma1xl = gamma1x.low;\r\n                const gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13))\r\n                    ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\r\n                const gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13))\r\n                    ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\r\n                // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\r\n                const Wi7 = W[i - 7];\r\n                const Wi7h = Wi7.high;\r\n                const Wi7l = Wi7.low;\r\n                const Wi16 = W[i - 16];\r\n                const Wi16h = Wi16.high;\r\n                const Wi16l = Wi16.low;\r\n                Wil = gamma0l + Wi7l;\r\n                Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\r\n                Wil = Wil + gamma1l;\r\n                Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\r\n                Wil = Wil + Wi16l;\r\n                Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\r\n                Wi.high = Wih;\r\n                Wi.low = Wil;\r\n            }\r\n            const chh = (eh & fh) ^ (~eh & gh);\r\n            const chl = (el & fl) ^ (~el & gl);\r\n            const majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\r\n            const majl = (al & bl) ^ (al & cl) ^ (bl & cl);\r\n            const sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\r\n            const sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\r\n            const sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\r\n            const sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\r\n            // t1 = h + sigma1 + ch + K[i] + W[i]\r\n            const Ki = K[i];\r\n            const Kih = Ki.high;\r\n            const Kil = Ki.low;\r\n            let t1l = hl + sigma1l;\r\n            let t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\r\n            t1l = t1l + chl;\r\n            t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\r\n            t1l = t1l + Kil;\r\n            t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\r\n            t1l = t1l + Wil;\r\n            t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\r\n            // t2 = sigma0 + maj\r\n            const t2l = sigma0l + majl;\r\n            const t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\r\n            // Update working variables\r\n            hh = gh;\r\n            hl = gl;\r\n            gh = fh;\r\n            gl = fl;\r\n            fh = eh;\r\n            fl = el;\r\n            el = (dl + t1l) | 0;\r\n            eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\r\n            dh = ch;\r\n            dl = cl;\r\n            ch = bh;\r\n            cl = bl;\r\n            bh = ah;\r\n            bl = al;\r\n            al = (t1l + t2l) | 0;\r\n            ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\r\n        }\r\n        // Intermediate hash value\r\n        H0l = H0.low = (H0l + al);\r\n        H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\r\n        H1l = H1.low = (H1l + bl);\r\n        H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\r\n        H2l = H2.low = (H2l + cl);\r\n        H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\r\n        H3l = H3.low = (H3l + dl);\r\n        H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\r\n        H4l = H4.low = (H4l + el);\r\n        H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\r\n        H5l = H5.low = (H5l + fl);\r\n        H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\r\n        H6l = H6.low = (H6l + gl);\r\n        H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\r\n        H7l = H7.low = (H7l + hl);\r\n        H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\r\n        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\r\n        data.nSigBytes = dataWords.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Convert hash to 32-bit word array before returning\r\n        return this._hash.to32();\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA512(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA512(props).finalize(message);\r\n    }\r\n}\r\n","export { Word32Array, Word64Array, Word64, Base64, Hex, Latin1, Utf8, Utf16, Utf16BE, Utf16LE, OpenSSLKDF, EvpKDF, PBKDF2, } from \"./lib/index\";\r\nexport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nexport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nexport { Hmac } from \"./Hmac\";\r\nexport { HmacMD5 } from \"./HmacMD5\";\r\nexport { HmacSHA224 } from \"./HmacSHA224\";\r\nexport { HmacSHA256 } from \"./HmacSHA256\";\r\nexport { HmacSHA384 } from \"./HmacSHA384\";\r\nexport { HmacSHA512 } from \"./HmacSHA512\";\r\nexport { MD5 } from \"./MD5\";\r\nexport { SHA1 } from \"./SHA1\";\r\nexport { SHA224 } from \"./SHA224\";\r\nexport { SHA256 } from \"./SHA256\";\r\nexport { SHA384 } from \"./SHA384\";\r\nexport { SHA512 } from \"./SHA512\";\r\nexport { SHA3 } from \"./SHA3\";\r\nexport { AES } from \"./AES\";\r\nexport { DES } from \"./DES\";\r\nexport { DES3 } from \"./DES3\";\r\nexport { RIPEMD160 } from \"./RIPEMD160\";\r\nexport { Rabbit } from \"./Rabbit\";\r\nexport { RC4 } from \"./RC4\";\r\nexport { RC4Drop } from \"./RC4Drop\";\r\nimport { CBC } from \"./mode/CBC\";\r\nimport { CFB } from \"./mode/CFB\";\r\nimport { CTR } from \"./mode/CTR\";\r\nimport { ECB } from \"./mode/ECB\";\r\nimport { OFB } from \"./mode/OFB\";\r\nexport const mode = {\r\n    CBC,\r\n    CFB,\r\n    CTR,\r\n    ECB,\r\n    OFB,\r\n};\r\nimport { AnsiX923 } from \"./pad/AnsiX923\";\r\nimport { ISO10126 } from \"./pad/ISO10126\";\r\nimport { ISO97971 } from \"./pad/ISO97971\";\r\nimport { Pkcs7 } from \"./pad/Pkcs7\";\r\nimport { Noop } from \"./pad/Noop\";\r\nimport { Zero } from \"./pad/Zero\";\r\nexport const pad = {\r\n    AnsiX923,\r\n    ISO10126,\r\n    ISO97971,\r\n    Pkcs7,\r\n    Noop,\r\n    Zero,\r\n};\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { random } from \"./random\";\r\n/**\r\n * An array of 32bit words\r\n */\r\nexport class Word32Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 4;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this);\r\n        }\r\n        return encoder.stringify(this);\r\n    }\r\n    /**\r\n     * Concatenates a word array to this word array.\r\n     *\r\n     * @param {Word32Array} w The word array to append.\r\n     * @return {Word32Array} This word array.\r\n     * @example\r\n     *   wordArray1.concat(wordArray2);\r\n     */\r\n    concat(w) {\r\n        const words = w.words.slice();\r\n        const N = w.nSigBytes;\r\n        this.clamp();\r\n        if (this._nSignificantBytes % 4) {\r\n            // Copy one byte at a time\r\n            for (let i = 0; i < N; i++) {\r\n                const b = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n                this._words[(this._nSignificantBytes + i) >>> 2] |= b << (24 - ((this._nSignificantBytes + i) % 4) * 8);\r\n            }\r\n        }\r\n        else {\r\n            // Copy one word at a time\r\n            for (let i = 0; i < N; i += 4) {\r\n                this._words[(this._nSignificantBytes + i) >>> 2] = words[i >>> 2];\r\n            }\r\n        }\r\n        this._nSignificantBytes += N;\r\n        // Chainable\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes insignificant bits.\r\n     *\r\n     * @example\r\n     *   wordArray.clamp();\r\n     */\r\n    clamp() {\r\n        const n = this._nSignificantBytes;\r\n        this._words[n >>> 2] &= 0xffffffff << (32 - (n % 4) * 8);\r\n        this._words.length = Math.ceil(n / 4);\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word32Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        return new Word32Array(this._words.slice(), this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Creates a word array filled with random bytes.\r\n     *\r\n     * @param {number} nBytes The number of random bytes to generate.\r\n     * @return {Word32Array} The random word array.\r\n     * @static\r\n     * @example\r\n     *   var wordArray = CryptoJS.lib.WordArray.random(16);\r\n     */\r\n    static random(nBytes) {\r\n        const words = [];\r\n        for (let i = 0; i < nBytes; i++) {\r\n            words.push(random());\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n}\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { Word32Array } from \"./Word32Array\";\r\nexport class Word64 {\r\n    constructor(high, low) {\r\n        this.high = high;\r\n        this.low = low;\r\n    }\r\n    clone() {\r\n        return new Word64(this.high, this.low);\r\n    }\r\n}\r\n/**\r\n * An array of 64bit words\r\n */\r\nexport class Word64Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 8;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this 64-bit word array to a 32-bit word array.\r\n     *\r\n     * @return {Word32Array} This word array's data as a 32-bit word array.\r\n     *\r\n     * @example\r\n     *\r\n     *     var x32WordArray = x64WordArray.toX32();\r\n     */\r\n    to32() {\r\n        const words32 = [];\r\n        for (let i = 0; i < this._words.length; i++) {\r\n            const word64 = this._words[i];\r\n            words32.push(word64.high);\r\n            words32.push(word64.low);\r\n        }\r\n        return new Word32Array(words32, this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this.to32());\r\n        }\r\n        return encoder.stringify(this.to32());\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word64Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        const words = this._words.slice();\r\n        for (let i = 0; i < words.length; i++) {\r\n            words[i] = words[i].clone();\r\n        }\r\n        return new Word64Array(words, this._nSignificantBytes);\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nimport { Utf8 } from \"../encoder/Utf8\";\r\nexport class BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        this._minBufferSize = 0;\r\n        this._blockSize = 0;\r\n        this._props = props;\r\n        this._data = props && typeof props.data !== \"undefined\" ? props.data.clone() : new Word32Array();\r\n        this._nBytes = props && typeof props.nBytes === \"number\" ? props.nBytes : 0;\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *   bufferedBlockAlgorithm.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        this._data = typeof data !== \"undefined\" ? data.clone() : new Word32Array();\r\n        this._nBytes = typeof nBytes === \"number\" ? nBytes : 0;\r\n    }\r\n    /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {Word32Array|string} data The data to append. Strings are converted to a WordArray using UTF-8.\r\n     * @example\r\n     *   bufferedBlockAlgorithm.append('data');\r\n     *   bufferedBlockAlgorithm.append(wordArray);\r\n     */\r\n    _append(data) {\r\n        const d = typeof data === \"string\" ? Utf8.parse(data) : data;\r\n        this._data.concat(d);\r\n        this._nBytes += d.nSigBytes;\r\n    }\r\n    /**\r\n     * Processes available data blocks.\r\n     * This method invokes doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean?} doFlush Whether all blocks and partial blocks should be processed.\r\n     * @return {Word32Array} The processed data.\r\n     * @example\r\n     *   var processedData = bufferedBlockAlgorithm.process();\r\n     *   var processedData = bufferedBlockAlgorithm.process(!!'flush');\r\n     */\r\n    _process(doFlush) {\r\n        let processedWords;\r\n        const words = this._data.words;\r\n        const nSigBytes = this._data.nSigBytes;\r\n        const blockSize = this._blockSize;\r\n        const blockSizeByte = this._blockSize * 4;\r\n        let nBlocksReady = nSigBytes / blockSizeByte;\r\n        if (doFlush) {\r\n            // Round up to include partial blocks\r\n            nBlocksReady = Math.ceil(nBlocksReady);\r\n        }\r\n        else {\r\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n        }\r\n        // Count words ready\r\n        const nWordsReady = nBlocksReady * blockSize;\r\n        // Count bytes ready\r\n        const nBytesReady = Math.min(nWordsReady * 4, nSigBytes);\r\n        // Process blocks\r\n        if (nWordsReady) {\r\n            for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n                // Perform concrete-algorithm logic\r\n                this._doProcessBlock(words, offset);\r\n            }\r\n            // Remove processed words\r\n            processedWords = words.splice(0, nWordsReady);\r\n            this._data.nSigBytes -= nBytesReady;\r\n        }\r\n        // Return processed words\r\n        return new Word32Array(processedWords, nBytesReady);\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"./BufferedBlockAlgorithm\";\r\nexport class Hasher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 512 / 32;\r\n        this._props = props;\r\n        if (props && typeof props.blockSize === \"number\") {\r\n            this._blockSize = props.blockSize;\r\n        }\r\n        this.reset(props ? props.data : undefined, props ? props.nBytes : undefined);\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this hasher to its initial state.\r\n     *\r\n     * @example\r\n     *   hasher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        // Reset data buffer\r\n        super.reset.call(this, data, nBytes);\r\n        // Perform concrete-hasher logic\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Updates this hasher with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hasher} This hasher.\r\n     * @example\r\n     *   hasher.update('message');\r\n     *   hasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._append(messageUpdate);\r\n        this._process();\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the hash computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string?} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The hash.\r\n     * @example\r\n     *   var hash = hasher.finalize();\r\n     *   var hash = hasher.finalize('message');\r\n     *   var hash = hasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        // Final message update\r\n        if (messageUpdate) {\r\n            this._append(messageUpdate);\r\n        }\r\n        // Perform concrete-hasher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { Cipher } from \"./Cipher\";\r\nimport { ECB } from \"./mode/ECB\";\r\nimport { Noop } from \"./pad/Noop\";\r\nexport class BlockCipher extends Cipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 128 / 32;\r\n        this._Mode = ECB;\r\n        this._padding = Noop;\r\n        this._props = props;\r\n        this._Mode = typeof props.mode !== \"undefined\" ? props.mode : this._Mode;\r\n        this._padding = typeof props.padding !== \"undefined\" ? props.padding : this._padding;\r\n        this.reset(props === null || props === void 0 ? void 0 : props.data, props === null || props === void 0 ? void 0 : props.nBytes);\r\n    }\r\n    get mode() {\r\n        return this._mode;\r\n    }\r\n    get padding() {\r\n        return this._padding;\r\n    }\r\n    reset(data, nBytes) {\r\n        super.reset(data, nBytes);\r\n        let modeCreator;\r\n        if (this._transformMode === Cipher.ENC_TRANSFORM_MODE) {\r\n            modeCreator = this._Mode.createEncryptor;\r\n        }\r\n        else {\r\n            modeCreator = this._Mode.createDecryptor;\r\n            // Keep at least one block in the buffer for unpadding\r\n            this._minBufferSize = 1;\r\n        }\r\n        if (this._Mode && this._modeCreator === modeCreator) {\r\n            this._mode = new this._Mode({ cipher: this, iv: this._iv && this._iv.words });\r\n        }\r\n        else {\r\n            this._mode = modeCreator.call(this._Mode, { cipher: this, iv: this._iv && this._iv.words });\r\n            this._modeCreator = modeCreator;\r\n        }\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        var _a;\r\n        (_a = this._mode) === null || _a === void 0 ? void 0 : _a.processBlock(words, offset);\r\n    }\r\n    _doFinalize() {\r\n        let finalProcessedBlocks;\r\n        // Shortcut\r\n        const padding = this._padding;\r\n        // Finalize\r\n        if (this._transformMode === Cipher.ENC_TRANSFORM_MODE) {\r\n            // Pad data\r\n            padding.pad(this._data, this.blockSize);\r\n            // Process final blocks\r\n            finalProcessedBlocks = this._process(true);\r\n        }\r\n        else /* if (this._transformMode == Cipher._DEC_TRANSFORM_MODE) */ {\r\n            // Process final blocks\r\n            finalProcessedBlocks = this._process(true);\r\n            // Unpad data\r\n            padding.unpad(finalProcessedBlocks);\r\n        }\r\n        return finalProcessedBlocks;\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    encryptBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    decryptBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *     var cipher = JsCrypto.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new BlockCipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new BlockCipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"../BufferedBlockAlgorithm\";\r\nexport class Cipher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._transformMode = 1;\r\n        this._props = props;\r\n        this._key = props.key;\r\n        this._iv = typeof props.iv !== \"undefined\" ? props.iv : this._iv;\r\n        this._transformMode = typeof props.transformMode !== \"undefined\" ? props.transformMode : this._transformMode;\r\n    }\r\n    get iv() {\r\n        return this._iv;\r\n    }\r\n    /**\r\n     * Resets this cipher to its initial state.\r\n     * @example\r\n     *   cipher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        super.reset(data, nBytes);\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Adds data to be encrypted or decrypted.\r\n     * @param {Word32Array|string} dataUpdate The data to encrypt or decrypt.\r\n     * @return {Word32Array} The data after processing.\r\n     * @example\r\n     *   var encrypted = cipher.process('data');\r\n     *   var encrypted = cipher.process(wordArray);\r\n     */\r\n    process(dataUpdate) {\r\n        this._append(dataUpdate);\r\n        return this._process();\r\n    }\r\n    /**\r\n     * Finalizes the encryption or decryption process.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     * @param {Word32Array|string?} dataUpdate The final data to encrypt or decrypt.\r\n     * @return {Word32Array} The data after final processing.\r\n     * @example\r\n     *   var encrypted = cipher.finalize();\r\n     *   var encrypted = cipher.finalize('data');\r\n     *   var encrypted = cipher.finalize(wordArray);\r\n     */\r\n    finalize(dataUpdate) {\r\n        // Final data update\r\n        if (dataUpdate) {\r\n            this._append(dataUpdate);\r\n        }\r\n        // Perform concrete-cipher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Cipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Cipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n}\r\nCipher.ENC_TRANSFORM_MODE = 1;\r\nCipher.DEC_TRANSFORM_MODE = 2;\r\nCipher.keySize = 128 / 32;\r\nCipher.ivSize = 128 / 32;\r\n","import { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\n/**\r\n * A collection of cipher parameters.\r\n *\r\n * @property {Word32Array} ciphertext The raw ciphertext.\r\n * @property {Word32Array} key The key to this ciphertext.\r\n * @property {Word32Array} iv The IV used in the ciphering operation.\r\n * @property {Word32Array} salt The salt used with a key derivation function.\r\n * @property {typeof Cipher} algorithm The cipher algorithm.\r\n * @property {BlockCipherMode} mode The block mode used in the ciphering operation.\r\n * @property {Pad} padding The padding scheme used in the ciphering operation.\r\n * @property {number} blockSize The block size of the cipher.\r\n * @property {Formatter} formatter The default formatting strategy to convert this cipher params object to a string.\r\n */\r\nexport class CipherParams {\r\n    /**\r\n     * Initializes a newly created cipher params object.\r\n     *\r\n     * @param {Partial<CipherParams>} cp An object with any of the possible cipher parameters.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.lib.CipherParams.create({\r\n     *       ciphertext: ciphertextWordArray,\r\n     *       key: keyWordArray,\r\n     *       iv: ivWordArray,\r\n     *       salt: saltWordArray,\r\n     *       algorithm: JsCrypto.AES,\r\n     *       mode: JsCrypto.CBC,\r\n     *       padding: JsCrypto.PKCS7,\r\n     *       blockSize: 4,\r\n     *       formatter: JsCrypto.OpenSSLFormatter\r\n     *     });\r\n     */\r\n    constructor(cp) {\r\n        this.formatter = OpenSSLFormatter;\r\n        if (cp) {\r\n            this.cipherText = cp.cipherText;\r\n            this.key = cp.key;\r\n            this.iv = cp.iv;\r\n            this.salt = cp.salt;\r\n            this.Algorithm = cp.Algorithm;\r\n            this.mode = cp.mode;\r\n            this.padding = cp.padding;\r\n            this.blockSize = cp.blockSize;\r\n            this.formatter = cp.formatter || OpenSSLFormatter;\r\n        }\r\n    }\r\n    /**\r\n     * Converts this cipher params object to a string.\r\n     *\r\n     * @param {Formatter?} formatter (Optional) The formatting strategy to use.\r\n     * @return {string} The stringified cipher params.\r\n     * @throws Error If neither the formatter nor the default formatter is set.\r\n     * @example\r\n     *   var string = cipherParams + '';\r\n     *   var string = cipherParams.toString();\r\n     *   var string = cipherParams.toString(CryptoJS.format.OpenSSL);\r\n     */\r\n    toString(formatter) {\r\n        return (formatter || this.formatter).stringify(this);\r\n    }\r\n}\r\n","import { parseCipherText, SerializableCipher, } from \"./SerializableCipher\";\r\nimport { OpenSSLKDF } from \"./kdf/OpenSSLKDF\";\r\nimport { CipherParams } from \"./CipherParams\";\r\nimport { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\nexport const PasswordBasedCipher = {\r\n    /**\r\n     * Encrypts a message using a password.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {Word32Array|string} message The message to encrypt.\r\n     * @param {string} password The password.\r\n     * @param {Partial<PasswordBasedCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {CipherParams} A cipher params object.\r\n     * @example\r\n     *   var params = JsCrypto.PasswordBasedCipher.encrypt(JsCrypto.AES, message, 'password');\r\n     *   var params = JsCrypto.PasswordBasedCipher.encrypt(JsCrypto.AES, message, 'password', { format: JsCrypto.OpenSSLFormatter });\r\n     */\r\n    encrypt(Cipher, message, password, props) {\r\n        const p = props ? Object.assign({}, props) : {};\r\n        const KDF = props && props.KDF ? props.KDF : OpenSSLKDF;\r\n        const derivedParams = KDF.execute(password, Cipher.keySize, Cipher.ivSize);\r\n        p.iv = derivedParams.iv;\r\n        const cipherParams = SerializableCipher.encrypt(Cipher, message, derivedParams.key, p);\r\n        return new CipherParams(Object.assign(Object.assign({}, cipherParams), { key: derivedParams.key, iv: derivedParams.iv, salt: derivedParams.salt }));\r\n    },\r\n    /**\r\n     * Decrypts serialized ciphertext using a password.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {CipherParams|string} cipherText The ciphertext to decrypt.\r\n     * @param {string} password The password.\r\n     * @param {Partial<PasswordBasedCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Word32Array} The plaintext.\r\n     * @example\r\n     *   var plaintext = JsCrypto.PasswordBasedCipher.decrypt(\r\n     *     JsCrypto.AES,\r\n     *     formattedCiphertext,\r\n     *     'password',\r\n     *     { format: JsCrypto.OpenSSLFormatter }\r\n     *   );\r\n     *   var plaintext = JsCrypto.PasswordBasedCipher.decrypt(\r\n     *     JsCrypto.AES,\r\n     *     ciphertextParams,\r\n     *     'password',\r\n     *     { format: JsCrypto.OpenSSLFormatter }\r\n     *   );\r\n     */\r\n    decrypt(Cipher, cipherText, password, props) {\r\n        const p = props ? Object.assign({}, props) : {};\r\n        const KDF = p.KDF ? p.KDF : OpenSSLKDF;\r\n        const formatter = p.formatter ? p.formatter : OpenSSLFormatter;\r\n        const cipherTextParams = parseCipherText(cipherText, formatter);\r\n        const derivedParams = KDF.execute(password, Cipher.keySize, Cipher.ivSize);\r\n        p.iv = derivedParams.iv;\r\n        return SerializableCipher.decrypt(Cipher, cipherTextParams, derivedParams.key, props);\r\n    }\r\n};\r\n","import { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\nimport { CipherParams } from \"./CipherParams\";\r\n/**\r\n * Converts serialized ciphertext to CipherParams,\r\n * else assumed CipherParams already and returns ciphertext unchanged.\r\n * @param {CipherParams|string} cipherTextParams The ciphertext.\r\n * @param {Formatter} formatter The formatting strategy to use to parse serialized ciphertext.\r\n * @return {CipherParams} The un-serialized ciphertext.\r\n * @example\r\n *   var ciphertextParams = JsCrypto.SerializableCipher.parse(ciphertextStringOrParams, format);\r\n */\r\nexport function parseCipherText(cipherTextParams, formatter) {\r\n    if (typeof cipherTextParams === \"string\") {\r\n        return formatter.parse(cipherTextParams);\r\n    }\r\n    return cipherTextParams;\r\n}\r\nexport const SerializableCipher = {\r\n    /**\r\n     * Encrypts a message.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {Word32Array|string} message The message to encrypt.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<SerializableCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {CipherParams} A cipher params object.\r\n     * @example\r\n     *   var ciphertextParams = JsCrypto.SerializableCipher.encrypt(JsCrypto.AES, message, key);\r\n     *   var ciphertextParams = JsCrypto.SerializableCipher.encrypt(JsCrypto.AES, message, key, { iv: iv });\r\n     */\r\n    encrypt(Cipher, message, key, props) {\r\n        const encryptor = Cipher.createEncryptor(key, props);\r\n        const cipherText = encryptor.finalize(message);\r\n        return new CipherParams({\r\n            cipherText,\r\n            key,\r\n            iv: encryptor.iv,\r\n            Algorithm: Cipher,\r\n            mode: encryptor.mode,\r\n            padding: encryptor.padding,\r\n            blockSize: encryptor.blockSize,\r\n            formatter: (props === null || props === void 0 ? void 0 : props.formatter) || OpenSSLFormatter,\r\n        });\r\n    },\r\n    /**\r\n     * Decrypts serialized ciphertext.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {CipherParams|string} cipherText The ciphertext to decrypt.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<SerializableCipherProps>} props (Optional) The configuration options to use for this operation.\r\n     * @return {Word32Array} The plaintext.\r\n     * @example\r\n     *     var plaintext = JsCrypto.SerializableCipher.decrypt(JsCrypto.AES, formattedCiphertext, key, { iv: iv, format: JsCrypto.OpenSSL });\r\n     *     var plaintext = JsCrypto.SerializableCipher.decrypt(JsCrypto.AES, ciphertextParams, key, { iv: iv, format: JsCrypto.OpenSSL });\r\n     */\r\n    decrypt(Cipher, cipherText, key, props) {\r\n        const decryptor = Cipher.createDecryptor(key, props);\r\n        const cipherParams = parseCipherText(cipherText, (props === null || props === void 0 ? void 0 : props.formatter) || OpenSSLFormatter);\r\n        return decryptor.finalize(cipherParams.cipherText || \"\");\r\n    }\r\n};\r\n","import { Cipher } from \"./Cipher\";\r\nexport class StreamCipher extends Cipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 1;\r\n    }\r\n    _doFinalize() {\r\n        return this._process(true);\r\n    }\r\n}\r\n","import { CipherParams } from \"../CipherParams\";\r\nimport { Word32Array } from \"../../../Word32Array\";\r\nimport { Base64 } from \"../../../encoder/Base64\";\r\nexport const OpenSSLFormatter = {\r\n    /**\r\n     * Converts a cipher params object to an OpenSSL-compatible string.\r\n     *\r\n     * @param {CipherParams} cipherParams The cipher params object.\r\n     * @return {string} The OpenSSL-compatible string.\r\n     * @example\r\n     *   var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\r\n     */\r\n    stringify(cipherParams) {\r\n        // Shortcuts\r\n        const cipherText = cipherParams.cipherText;\r\n        const salt = cipherParams.salt;\r\n        if (!cipherText) {\r\n            return \"\";\r\n        }\r\n        // Format\r\n        if (salt) {\r\n            const wordArray = new Word32Array([0x53616c74, 0x65645f5f]).concat(salt).concat(cipherText);\r\n            return wordArray.toString(Base64);\r\n        }\r\n        return cipherText.toString(Base64);\r\n    },\r\n    /**\r\n     * Converts an OpenSSL-compatible string to a cipher params object.\r\n     *\r\n     * @param {string} openSSLStr The OpenSSL-compatible string.\r\n     * @return {CipherParams} The cipher params object.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\r\n     */\r\n    parse(openSSLStr) {\r\n        let salt;\r\n        // Parse base64\r\n        const cipherText = Base64.parse(openSSLStr);\r\n        // Shortcut\r\n        const ciphertextWords = cipherText.words;\r\n        // Test for salt\r\n        if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\r\n            // Extract salt\r\n            salt = new Word32Array(ciphertextWords.slice(2, 4));\r\n            // Remove salt from ciphertext\r\n            ciphertextWords.splice(0, 4);\r\n            cipherText.nSigBytes -= 16;\r\n        }\r\n        return new CipherParams({ cipherText, salt });\r\n    }\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\nimport { CipherParams } from \"../CipherParams\";\r\nimport { EvpKDF } from \"./module/EvpKDF\";\r\n/**\r\n * Derives a key and IV from a password.\r\n *\r\n * @param {string} password The password to derive from.\r\n * @param {number} keySize The size in words of the key to generate.\r\n * @param {number} ivSize The size in words of the IV to generate.\r\n * @param {Word32Array?} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\r\n * @return {CipherParams} A cipher params object with the key, IV, and salt.\r\n * @example\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32);\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32, 'saltsalt');\r\n */\r\nexport const OpenSSLKDF = {\r\n    execute(password, keySize, ivSize, salt, props) {\r\n        // Generate random salt\r\n        if (!salt) {\r\n            salt = Word32Array.random(64 / 8);\r\n        }\r\n        const KDFModule = props && props.KDF || EvpKDF;\r\n        const kdfProps = props ? { Hasher: props.Hasher, iterations: props.iterations } : {};\r\n        // Derive key and IV\r\n        const key = KDFModule.getKey(password, salt, Object.assign(Object.assign({}, kdfProps), { keySize: keySize + ivSize }));\r\n        // Separate key and IV\r\n        const iv = new Word32Array(key.words.slice(keySize), ivSize * 4);\r\n        key.nSigBytes = keySize * 4;\r\n        // Return params\r\n        return new CipherParams({ key, iv, salt });\r\n    }\r\n};\r\n","import { MD5 } from \"../../../../../MD5\";\r\nimport { Word32Array } from \"../../../../Word32Array\";\r\nimport { BaseKDFModule } from \"../type\";\r\n/**\r\n * This key derivation function is meant to conform with EVP_BytesToKey.\r\n * https://www.openssl.org/docs/man1.1.1/man3/EVP_BytesToKey.html\r\n *\r\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n * @property {Hasher} hasher The hash algorithm to use. Default: MD5\r\n * @property {number} iterations The number of iterations to perform. Default: 1\r\n */\r\nexport class EvpKDF extends BaseKDFModule {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keySize = 128 / 32;\r\n        this._Hasher = MD5;\r\n        this._iterations = 1;\r\n        if (props) {\r\n            this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\r\n            this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\r\n            this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\r\n        }\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @return {Word32Array} The derived key.\r\n     * @example\r\n     *   var key = kdf.compute(password, salt);\r\n     */\r\n    compute(password, salt) {\r\n        let block;\r\n        // Init hasher\r\n        const hasher = new this._Hasher();\r\n        // Initial values\r\n        const derivedKey = new Word32Array();\r\n        // Shortcuts\r\n        const derivedKeyWords = derivedKey.words;\r\n        const keySize = this._keySize;\r\n        const iterations = this._iterations;\r\n        // Generate key\r\n        while (derivedKeyWords.length < keySize) {\r\n            if (block) {\r\n                hasher.update(block);\r\n            }\r\n            block = hasher.update(password).finalize(salt);\r\n            hasher.reset();\r\n            // Iterations\r\n            for (let i = 1; i < iterations; i++) {\r\n                block = hasher.finalize(block);\r\n                hasher.reset();\r\n            }\r\n            derivedKey.concat(block);\r\n        }\r\n        derivedKey.nSigBytes = keySize * 4;\r\n        return derivedKey;\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @param {Partial<EvpKDFProps>?} props (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {Word32Array} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = EvpKDF.getKey(password, salt);\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8 });\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\r\n    static getKey(password, salt, props) {\r\n        return new EvpKDF(props).compute(password, salt);\r\n    }\r\n}\r\n","import { SHA1 } from \"../../../../../SHA1\";\r\nimport { Hmac } from \"../../../../../Hmac\";\r\nimport { Word32Array } from \"../../../../Word32Array\";\r\nimport { BaseKDFModule } from \"../type\";\r\n/**\r\n * Password-Based Key Derivation Function 2 algorithm.\r\n *\r\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n * @property {Hasher} hasher The hash algorithm to use. Default: SHA1\r\n * @property {number} iterations The number of iterations to perform. Default: 1\r\n */\r\nexport class PBKDF2 extends BaseKDFModule {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keySize = 128 / 32;\r\n        this._Hasher = SHA1;\r\n        this._iterations = 1;\r\n        if (props) {\r\n            this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\r\n            this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\r\n            this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\r\n        }\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @return {Word32Array} The derived key.\r\n     * @example\r\n     *   var key = kdf.compute(password, salt);\r\n     */\r\n    compute(password, salt) {\r\n        // Init HMAC\r\n        const hmac = new Hmac(new this._Hasher(), password);\r\n        // Initial values\r\n        const derivedKey = new Word32Array();\r\n        const blockIndex = new Word32Array([0x00000001]);\r\n        // Shortcuts\r\n        const derivedKeyWords = derivedKey.words;\r\n        const blockIndexWords = blockIndex.words;\r\n        const keySize = this._keySize;\r\n        const iterations = this._iterations;\r\n        // Generate key\r\n        while (derivedKeyWords.length < keySize) {\r\n            const block = hmac.update(salt).finalize(blockIndex);\r\n            hmac.reset();\r\n            // Shortcuts\r\n            const blockWords = block.words;\r\n            const blockWordsLength = blockWords.length;\r\n            // Iterations\r\n            let intermediate = block;\r\n            for (let i = 1; i < iterations; i++) {\r\n                intermediate = hmac.finalize(intermediate);\r\n                hmac.reset();\r\n                // Shortcut\r\n                const intermediateWords = intermediate.words;\r\n                // XOR intermediate with block\r\n                for (let j = 0; j < blockWordsLength; j++) {\r\n                    blockWords[j] ^= intermediateWords[j];\r\n                }\r\n            }\r\n            derivedKey.concat(block);\r\n            blockIndexWords[0]++;\r\n        }\r\n        derivedKey.nSigBytes = keySize * 4;\r\n        return derivedKey;\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @param {Partial<PBKDF2Props>?} props (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {Word32Array} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = PBKDF2.getKey(password, salt);\r\n     *     var key = PBKDF2.getKey(password, salt, { keySize: 8 });\r\n     *     var key = PBKDF2.getKey(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\r\n    static getKey(password, salt, props) {\r\n        return new PBKDF2(props).compute(password, salt);\r\n    }\r\n}\r\n","export class BaseKDFModule {\r\n    constructor(props) {\r\n        this._props = props;\r\n    }\r\n    compute(password, salt) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    static getKey(password, salt, props) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","/**\r\n * Abstract base block cipher mode template.\r\n * @abstract\r\n */\r\nexport class BlockCipherMode {\r\n    constructor(props) {\r\n        this._props = props;\r\n        this._cipher = props.cipher;\r\n        this._iv = props.iv;\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    processBlock(words, offset) {\r\n        return;\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @abstract\r\n     * @example\r\n     *   var mode = JsCrypto.CBC.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        throw new Error(\"Not implemented yet\");\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @abstract\r\n     * @example\r\n     *   var mode = JsCrypto.CBC.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        throw new Error(\"Not implemented yet\");\r\n    }\r\n}\r\n","import { BlockCipherMode } from \"./BlockCipherMode\";\r\nexport class CBC extends BlockCipherMode {\r\n    constructor(props) {\r\n        super(props);\r\n        this._prevBlock = [];\r\n    }\r\n    xorBlock(words, offset, blockSize) {\r\n        let block;\r\n        // Shortcut\r\n        const iv = this._iv;\r\n        // Choose mixing block\r\n        if (iv) {\r\n            block = iv;\r\n            // Remove IV for subsequent blocks\r\n            this._iv = undefined;\r\n        }\r\n        else {\r\n            block = this._prevBlock;\r\n        }\r\n        // XOR blocks\r\n        for (let i = 0; i < blockSize; i++) {\r\n            words[offset + i] ^= block[i];\r\n        }\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CBC.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        return new CBC.Encryptor(props);\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CBC.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        return new CBC.Decryptor(props);\r\n    }\r\n}\r\n/**\r\n * CBC encryptor.\r\n */\r\nCBC.Encryptor = class Encryptor extends CBC {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        // Shortcuts\r\n        const cipher = this._cipher;\r\n        const blockSize = cipher.blockSize;\r\n        // XOR and encrypt\r\n        this.xorBlock(words, offset, blockSize);\r\n        cipher.encryptBlock(words, offset);\r\n        // Remember this block to use with next block\r\n        this._prevBlock = words.slice(offset, offset + blockSize);\r\n    }\r\n};\r\n/**\r\n * CBC decryptor.\r\n */\r\nCBC.Decryptor = class Decryptor extends CBC {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        // Shortcuts\r\n        const cipher = this._cipher;\r\n        const blockSize = cipher.blockSize;\r\n        // Remember this block to use with next block\r\n        const thisBlock = words.slice(offset, offset + blockSize);\r\n        // Decrypt and XOR\r\n        cipher.decryptBlock(words, offset);\r\n        this.xorBlock(words, offset, blockSize);\r\n        // This block becomes the previous block\r\n        this._prevBlock = thisBlock;\r\n    }\r\n};\r\n","import { BlockCipherMode } from \"./BlockCipherMode\";\r\n/**\r\n * Cipher Feedback Block mode\r\n */\r\nexport class CFB extends BlockCipherMode {\r\n    constructor(props) {\r\n        super(props);\r\n        this._prevBlock = [];\r\n    }\r\n    generateKeyStreamAndEncrypt(words, offset, blockSize, cipher) {\r\n        let keyStream;\r\n        // Shortcut\r\n        const iv = this._iv;\r\n        // Generate keyStream\r\n        if (iv) {\r\n            keyStream = iv.slice(0);\r\n            // Remove IV for subsequent blocks\r\n            this._iv = undefined;\r\n        }\r\n        else {\r\n            keyStream = this._prevBlock;\r\n        }\r\n        cipher.encryptBlock(keyStream, 0);\r\n        // Encrypt\r\n        for (let i = 0; i < blockSize; i++) {\r\n            words[offset + i] ^= keyStream[i];\r\n        }\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CFB.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        return new CFB.Encryptor(props);\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CFB.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        return new CFB.Decryptor(props);\r\n    }\r\n}\r\n/**\r\n * CFB encryptor.\r\n */\r\nCFB.Encryptor = class Encryptor extends CFB {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        this.generateKeyStreamAndEncrypt(words, offset, this._cipher.blockSize, this._cipher);\r\n        // Remember this block to use with next block\r\n        this._prevBlock = words.slice(offset, offset + this._cipher.blockSize);\r\n    }\r\n};\r\n/**\r\n * CFB decryptor.\r\n */\r\nCFB.Decryptor = class Encryptor extends CFB {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        // Remember this block to use with next block\r\n        const thisBlock = words.slice(offset, offset + this._cipher.blockSize);\r\n        this.generateKeyStreamAndEncrypt(words, offset, this._cipher.blockSize, this._cipher);\r\n        // This block becomes the previous block\r\n        this._prevBlock = thisBlock;\r\n    }\r\n};\r\n","import { BlockCipherMode } from \"./BlockCipherMode\";\r\n/**\r\n * Output Feedback Block mode\r\n */\r\nexport class CTR extends BlockCipherMode {\r\n    constructor(props) {\r\n        super(props);\r\n        this._counter = [];\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CTR.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        return new CTR.Encryptor(props);\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.CTR.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        return new CTR.Decryptor(props);\r\n    }\r\n}\r\n/**\r\n * CTR encryptor.\r\n */\r\nCTR.Encryptor = class Encryptor extends CTR {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        // Shortcuts\r\n        const cipher = this._cipher;\r\n        const blockSize = cipher.blockSize;\r\n        const iv = this._iv;\r\n        let counter = this._counter;\r\n        // Generate keyStream\r\n        if (iv) {\r\n            counter = this._counter = iv.slice(0);\r\n            // Remove IV for subsequent blocks\r\n            this._iv = undefined;\r\n        }\r\n        const keyStream = counter.slice(0);\r\n        cipher.encryptBlock(keyStream, 0);\r\n        // Increment counter\r\n        counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\r\n        // Encrypt\r\n        for (let i = 0; i < blockSize; i++) {\r\n            words[offset + i] ^= keyStream[i];\r\n        }\r\n    }\r\n};\r\n/**\r\n * CTR decryptor.\r\n */\r\nCTR.Decryptor = CTR.Encryptor;\r\n","import { BlockCipherMode } from \"./BlockCipherMode\";\r\n/**\r\n * Electronic Codebook block mode.\r\n */\r\nexport class ECB extends BlockCipherMode {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.ECB.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        return new ECB.Encryptor(props);\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.ECB.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        return new ECB.Decryptor(props);\r\n    }\r\n}\r\n/**\r\n * ECB encryptor.\r\n */\r\nECB.Encryptor = class Encryptor extends ECB {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        this._cipher.encryptBlock(words, offset);\r\n    }\r\n};\r\n/**\r\n * ECB decryptor.\r\n */\r\nECB.Decryptor = class Decryptor extends ECB {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        this._cipher.decryptBlock(words, offset);\r\n    }\r\n};\r\n","import { BlockCipherMode } from \"./BlockCipherMode\";\r\n/**\r\n * Output Feedback Block mode\r\n */\r\nexport class OFB extends BlockCipherMode {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keyStream = [];\r\n    }\r\n    /**\r\n     * Creates this mode for encryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.OFB.createEncryptor(cipher, iv.words);\r\n     */\r\n    static createEncryptor(props) {\r\n        return new OFB.Encryptor(props);\r\n    }\r\n    /**\r\n     * Creates this mode for decryption.\r\n     * @param {BlockCipherModeProps} props\r\n     * @example\r\n     *   var mode = JsCrypto.OFB.createDecryptor(cipher, iv.words);\r\n     */\r\n    static createDecryptor(props) {\r\n        return new OFB.Decryptor(props);\r\n    }\r\n}\r\n/**\r\n * OFB encryptor.\r\n */\r\nOFB.Encryptor = class Encryptor extends OFB {\r\n    /**\r\n     * Processes the data block at offset.\r\n     *\r\n     * @param {number[]} words The data words to operate on.\r\n     * @param {number} offset The offset where the block starts.\r\n     * @example\r\n     *   mode.processBlock(data.words, offset);\r\n     */\r\n    processBlock(words, offset) {\r\n        // Shortcuts\r\n        const cipher = this._cipher;\r\n        const blockSize = cipher.blockSize;\r\n        const iv = this._iv;\r\n        let keyStream = this._keyStream;\r\n        // Generate key stream\r\n        if (iv) {\r\n            keyStream = this._keyStream = iv.slice(0);\r\n            // Remove IV for subsequent blocks\r\n            this._iv = undefined;\r\n        }\r\n        cipher.encryptBlock(keyStream, 0);\r\n        // Encrypt\r\n        for (let i = 0; i < blockSize; i++) {\r\n            words[offset + i] ^= keyStream[i];\r\n        }\r\n    }\r\n};\r\n/**\r\n * OFB decryptor.\r\n */\r\nOFB.Decryptor = OFB.Encryptor;\r\n","/**\r\n * ANSI X.923 padding strategy\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.AnsiX923.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Shortcuts\r\n    const dataSigBytes = data.nSigBytes;\r\n    const blockSizeBytes = blockSize * 4;\r\n    // Count padding bytes\r\n    const nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\r\n    // Compute last byte position\r\n    const lastBytePos = dataSigBytes + nPaddingBytes - 1;\r\n    // Pad\r\n    data.clamp();\r\n    data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\r\n    data.nSigBytes += nPaddingBytes;\r\n}\r\n/**\r\n * Unpads data that had been padded with ANSI X.923 padding strategy\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.AnsiX923.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Get number of padding bytes from last byte\r\n    const nPaddingBytes = data.words[(data.nSigBytes - 1) >>> 2] & 0xff;\r\n    // Remove padding\r\n    data.nSigBytes -= nPaddingBytes;\r\n}\r\nexport const AnsiX923 = {\r\n    pad,\r\n    unpad,\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\n/**\r\n * ISO10126 padding strategy\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.ISO10126.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Shortcut\r\n    const blockSizeBytes = blockSize * 4;\r\n    // Count padding bytes\r\n    const nPaddingBytes = blockSizeBytes - data.nSigBytes % blockSizeBytes;\r\n    // Pad\r\n    data\r\n        .concat(Word32Array.random(nPaddingBytes - 1))\r\n        .concat(new Word32Array([nPaddingBytes << 24], 1));\r\n}\r\n/**\r\n * Unpads data that had been padded with ISO10126 padding strategy.\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.ISO10126.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Get number of padding bytes from last byte\r\n    const nPaddingBytes = data.words[(data.nSigBytes - 1) >>> 2] & 0xff;\r\n    // Remove padding\r\n    data.nSigBytes -= nPaddingBytes;\r\n}\r\nexport const ISO10126 = {\r\n    pad,\r\n    unpad,\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\nimport { Zero } from \"./Zero\";\r\n/**\r\n * ISO/IEC 9797-1 Padding Method 2. padding strategy\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.ISO97971.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Add 0x80 byte\r\n    data.concat(new Word32Array([0x80000000], 1));\r\n    // Zero pad the rest\r\n    Zero.pad(data, blockSize);\r\n}\r\n/**\r\n * Unpads data that had been padded with ISO/IEC 9797-1 Padding Method 2 strategy.\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.ISO97971.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Remove zero padding\r\n    Zero.unpad(data);\r\n    // Remove one more byte -- the 0x80 byte\r\n    data.nSigBytes -= 1;\r\n}\r\nexport const ISO97971 = {\r\n    pad,\r\n    unpad,\r\n};\r\n","/**\r\n * A noop padding strategy\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.Noop.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Noop\r\n}\r\n/**\r\n * Unpads data that had been padded with Noop strategy.\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.Noop.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Noop\r\n}\r\nexport const Noop = {\r\n    pad,\r\n    unpad,\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\n/**\r\n * Pads data using the algorithm defined in PKCS #5/7.\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.Pkcs7.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Shortcut\r\n    const blockSizeBytes = blockSize * 4;\r\n    // Count padding bytes\r\n    const nPaddingBytes = blockSizeBytes - data.nSigBytes % blockSizeBytes;\r\n    // Create padding word\r\n    const paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\r\n    // Create padding\r\n    const paddingWords = [];\r\n    for (let i = 0; i < nPaddingBytes; i += 4) {\r\n        paddingWords.push(paddingWord);\r\n    }\r\n    const padding = new Word32Array(paddingWords, nPaddingBytes);\r\n    // Add padding\r\n    data.concat(padding);\r\n}\r\n/**\r\n * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.Pkcs7.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Get number of padding bytes from last byte\r\n    const nPaddingBytes = data.words[(data.nSigBytes - 1) >>> 2] & 0xff;\r\n    // Remove padding\r\n    data.nSigBytes -= nPaddingBytes;\r\n}\r\nexport const Pkcs7 = {\r\n    pad,\r\n    unpad,\r\n};\r\n","/**\r\n * Pads data with zero padding strategy.\r\n *\r\n * @param {Word32Array} data The data to pad.\r\n * @param {number} blockSize The multiple that the data should be padded to.\r\n * @example\r\n *   JsCrypto.pad.Zero.pad(wordArray, 4);\r\n */\r\nfunction pad(data, blockSize) {\r\n    // Shortcut\r\n    const blockSizeBytes = blockSize * 4;\r\n    // Pad\r\n    data.clamp();\r\n    data.nSigBytes += blockSizeBytes - ((data.nSigBytes % blockSizeBytes) || blockSizeBytes);\r\n}\r\n/**\r\n * Unpads data that had been padded with zero padding strategy.\r\n *\r\n * @param {Word32Array} data The data to unpad.\r\n * @example\r\n *   JsCrypto.pad.Zero.unpad(wordArray);\r\n */\r\nfunction unpad(data) {\r\n    // Shortcut\r\n    const dataWords = data.words;\r\n    // Unpad\r\n    for (let i = data.nSigBytes - 1; i >= 0; i--) {\r\n        if ((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff) {\r\n            data.nSigBytes = i + 1;\r\n            break;\r\n        }\r\n    }\r\n}\r\nexport const Zero = {\r\n    pad,\r\n    unpad,\r\n};\r\n","const ua = typeof navigator !== \"undefined\" && navigator.userAgent ? navigator.userAgent.toLowerCase() : \"\";\r\nconst IEVer = (() => {\r\n    let ver = parseInt((/msie (\\d+)/.exec(ua) || [])[1], 10);\r\n    if (isNaN(ver)) {\r\n        ver = parseInt((/trident\\/.*; rv:(\\d+)/.exec(ua) || [])[1], 10);\r\n        if (isNaN(ver)) {\r\n            return false;\r\n        }\r\n        return ver;\r\n    }\r\n    return ver;\r\n})();\r\nexport function isIE(op, ver) {\r\n    if (IEVer === false)\r\n        return false;\r\n    if (!ver)\r\n        return true;\r\n    if (op === \"<\")\r\n        return IEVer < ver;\r\n    if (op === \"<=\")\r\n        return IEVer <= ver;\r\n    if (op === \">\")\r\n        return IEVer > ver;\r\n    if (op === \">=\")\r\n        return IEVer >= ver;\r\n    if (op === \"=\")\r\n        return IEVer === ver;\r\n    return IEVer === ver;\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nconst map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst reverseMap = [];\r\nfor (let i = 0; i < map.length; i++) {\r\n    reverseMap[map.charCodeAt(i)] = i;\r\n}\r\nexport const Base64 = {\r\n    /**\r\n     * Converts a word array to a base64 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The base64 string.\r\n     * @example\r\n     *   var hexString = Base64.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Clamp excess bits\r\n        w.clamp();\r\n        // Convert\r\n        const base64Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 3) {\r\n            const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\r\n            const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\r\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\r\n            for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\r\n                base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\r\n            }\r\n        }\r\n        // Add padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            while (base64Chars.length % 4) {\r\n                base64Chars.push(paddingChar);\r\n            }\r\n        }\r\n        return base64Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a base64 string to a word array.\r\n     *\r\n     * @param {string} base64Str The base64 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Base64.parse(base64String);\r\n     */\r\n    parse(base64Str) {\r\n        let base64StrLength = base64Str.length;\r\n        // Ignore padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            const paddingIndex = base64Str.indexOf(paddingChar);\r\n            if (paddingIndex !== -1) {\r\n                base64StrLength = paddingIndex;\r\n            }\r\n        }\r\n        const words = [];\r\n        let nBytes = 0;\r\n        for (let i = 0; i < base64StrLength; i++) {\r\n            if (i % 4) {\r\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\r\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\r\n                const bitsCombined = bits1 | bits2;\r\n                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\r\n                nBytes++;\r\n            }\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Hex = {\r\n    /**\r\n     * Converts a word array to a hex string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The hex string.\r\n     * @example\r\n     *   var hexString = Hex.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const hexChars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            hexChars.push((byte >>> 4).toString(16));\r\n            hexChars.push((byte & 0x0f).toString(16));\r\n        }\r\n        return hexChars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a hex string to a word array.\r\n     *\r\n     * @param {string} hexStr The hex string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Hex.parse(hexString);\r\n     */\r\n    parse(hexStr) {\r\n        const Len = hexStr.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i += 2) {\r\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\r\n        }\r\n        return new Word32Array(words, Len / 2);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Latin1 = {\r\n    /**\r\n     * Converts a word array to a Latin1 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The Latin1 string.\r\n     * @example\r\n     *   var latin1String = Latin1.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const latin1Chars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            latin1Chars.push(String.fromCharCode(byte));\r\n        }\r\n        return latin1Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a latin1 string to a word array.\r\n     *\r\n     * @param {string} latin1Str The latin1 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Latin1.parse(latin1Str);\r\n     */\r\n    parse(latin1Str) {\r\n        const Len = latin1Str.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i++) {\r\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\r\n        }\r\n        return new Word32Array(words, Len);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\n/**\r\n * UTF-16 BE encoding strategy.\r\n */\r\nexport const Utf16BE = {\r\n    /**\r\n     * Converts a word array to a UTF-16 BE string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-16 BE string.\r\n     * @example\r\n     *   var utf16String = Utf16.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Convert\r\n        const utf16Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 2) {\r\n            const codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\r\n            utf16Chars.push(String.fromCharCode(codePoint));\r\n        }\r\n        return utf16Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a UTF-16 BE string to a word array.\r\n     * @param {string} utf16Str The UTF-16 BE string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   const wordArray = Utf16.parse(utf16String);\r\n     */\r\n    parse(utf16Str) {\r\n        // Shortcut\r\n        const utf16StrLength = utf16Str.length;\r\n        // Convert\r\n        const words = [];\r\n        for (let i = 0; i < utf16StrLength; i++) {\r\n            words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\r\n        }\r\n        return new Word32Array(words, utf16StrLength * 2);\r\n    }\r\n};\r\nfunction swapEndian(word) {\r\n    return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\r\n}\r\n/**\r\n * UTF-16 LE encoding strategy.\r\n */\r\nexport const Utf16LE = {\r\n    /**\r\n     * Converts a word array to a UTF-16 LE string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-16 LE string.\r\n     * @example\r\n     *   var utf16String = Utf16.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Convert\r\n        const utf16Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 2) {\r\n            const codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\r\n            utf16Chars.push(String.fromCharCode(codePoint));\r\n        }\r\n        return utf16Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a UTF-16 LE string to a word array.\r\n     * @param {string} utf16Str The UTF-16 LE string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   const wordArray = Utf16.parse(utf16String);\r\n     */\r\n    parse(utf16Str) {\r\n        // Shortcut\r\n        const utf16StrLength = utf16Str.length;\r\n        // Convert\r\n        const words = [];\r\n        for (let i = 0; i < utf16StrLength; i++) {\r\n            words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\r\n        }\r\n        return new Word32Array(words, utf16StrLength * 2);\r\n    }\r\n};\r\nexport const Utf16 = Utf16BE;\r\n","import { Latin1 } from \"./Latin1\";\r\nexport const Utf8 = {\r\n    /**\r\n     * Converts a word array to a UTF-8 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-8 string.\r\n     * @example\r\n     *   var utf8String = Utf8.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        try {\r\n            return decodeURIComponent(escape(Latin1.stringify(w)));\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Malformed UTF-8 data\");\r\n        }\r\n    },\r\n    /**\r\n     * Converts a UTF-8 string to a word array.\r\n     *\r\n     * @param {string} utf8Str The UTF-8 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Utf8.parse(utf8Str);\r\n     */\r\n    parse(utf8Str) {\r\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\r\n    }\r\n};\r\n","export { random } from \"./random\";\r\nexport { Word32Array } from \"./Word32Array\";\r\nexport { Word64, Word64Array } from \"./Word64Array\";\r\nexport { isIE } from \"./browser\";\r\nexport { Base64 } from \"./encoder/Base64\";\r\nexport { Utf8 } from \"./encoder/Utf8\";\r\nexport { Latin1 } from \"./encoder/Latin1\";\r\nexport { Hex } from \"./encoder/Hex\";\r\nexport { Utf16BE, Utf16LE, Utf16 } from \"./encoder/Utf16\";\r\nexport { OpenSSLKDF } from \"./algorithm/cipher/kdf/OpenSSLKDF\";\r\nexport { PBKDF2 } from \"./algorithm/cipher/kdf/module/PBKDF2\";\r\nexport { EvpKDF } from \"./algorithm/cipher/kdf/module/EvpKDF\";\r\n","function makeRandFunction() {\r\n    if (typeof window !== \"undefined\") {\r\n        const c = window.crypto || window.msCrypto;\r\n        if (!c) {\r\n            throw new Error(\"Crypto module not found\");\r\n        }\r\n        return function rand() {\r\n            return c.getRandomValues(new Uint32Array(1))[0];\r\n        };\r\n    }\r\n    else if (typeof global !== \"undefined\" && global.crypto) {\r\n        return function rand() {\r\n            return global.crypto.randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    else if (typeof require === \"function\") {\r\n        return function rand() {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore\r\n            return __non_webpack_require__(\"crypto\").randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    throw new Error(\"Unable to find crypto module\");\r\n}\r\nexport const random = makeRandFunction();\r\n","export { CBC } from \"../lib/algorithm/cipher/mode/CBC\";\r\n","export { CFB } from \"../lib/algorithm/cipher/mode/CFB\";\r\n","export { CTR } from \"../lib/algorithm/cipher/mode/CTR\";\r\n","export { ECB } from \"../lib/algorithm/cipher/mode/ECB\";\r\n","export { OFB } from \"../lib/algorithm/cipher/mode/OFB\";\r\n","export { AnsiX923 } from \"../lib/algorithm/cipher/pad/AnsiX923\";\r\n","export { ISO10126 } from \"../lib/algorithm/cipher/pad/ISO10126\";\r\n","export { ISO97971 } from \"../lib/algorithm/cipher/pad/ISO97971\";\r\n","export { Noop } from \"../lib/algorithm/cipher/pad/Noop\";\r\n","export { Pkcs7 } from \"../lib/algorithm/cipher/pad/Pkcs7\";\r\n","export { Zero } from \"../lib/algorithm/cipher/pad/Zero\";\r\n"],"sourceRoot":""}