{"version":3,"sources":["webpack://JsCrypto/webpack/universalModuleDefinition","webpack://JsCrypto/webpack/bootstrap","webpack://JsCrypto/(webpack)/buildin/global.js","webpack://JsCrypto/./src/Hmac.ts","webpack://JsCrypto/./src/MD5.ts","webpack://JsCrypto/./src/SHA1.ts","webpack://JsCrypto/./src/lib/Word32Array.ts","webpack://JsCrypto/./src/lib/Word64Array.ts","webpack://JsCrypto/./src/lib/algorithm/BufferedBlockAlgorithm.ts","webpack://JsCrypto/./src/lib/algorithm/Hasher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/CipherParams.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/formatter/OpenSSLFormatter.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/OpenSSLKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/module/EvpKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/module/PBKDF2.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/type.ts","webpack://JsCrypto/./src/lib/browser.ts","webpack://JsCrypto/./src/lib/encoder/Base64.ts","webpack://JsCrypto/./src/lib/encoder/Hex.ts","webpack://JsCrypto/./src/lib/encoder/Latin1.ts","webpack://JsCrypto/./src/lib/encoder/Utf16.ts","webpack://JsCrypto/./src/lib/encoder/Utf8.ts","webpack://JsCrypto/./src/lib/index.ts","webpack://JsCrypto/./src/lib/random.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAA0C;AACnC;AACP;AACA;AACA;AACA;AACA,kBAAkB,sDAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,4DAAM;AAC/B;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACO,mBAAmB,4DAAM;AAChC;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAoC;AACF;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,uBAAuB,sDAAM;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACQ;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAA6C;AACN;AAChC;AACP;AACA;AACA;AACA;AACA,2FAA2F,wDAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wDAAW;AACjF;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAkE;AAC3D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAgE;AAChE;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;AACO;AACP;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,4EAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4EAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACI;AACF;AAC1C;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C,sCAAsC,sDAAM;AAC5C;AACA,mCAAmC,sDAAM;AACzC,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAM;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA;AACA,mBAAmB,0DAAY,EAAE,mBAAmB;AACpD;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACJ;AACN;AACzC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA,gDAAgD,qDAAM;AACtD,kCAAkC,qDAAqD;AACvF;AACA,mFAAmF,cAAc,4BAA4B;AAC7H;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA,mBAAmB,0DAAY,EAAE,gBAAgB;AACjD;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACa;AACd;AACxC;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO,qBAAqB,mDAAa;AACzC;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACA;AACW;AACd;AACxC;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO,qBAAqB,mDAAa;AACzC;AACA;AACA;AACA,uBAAuB,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA,+BAA+B,wDAAW;AAC1C,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAA6C;AAC7C;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAA6C;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACO;;;;;;;;;;;;;ACxFP;AAAA;AAAA;AAAkC;AAC3B;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAM;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACU;AACQ;AACnB;AACS;AACJ;AACI;AACN;AACsB;AACK;AACD;AACA;;;;;;;;;;;;;ACX9D;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAA6B;AAC1C;AACA;AACA;AACA,mBAAmB,OAAuB;AAC1C;AACA;AACA;AACA;AACO","file":"lib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsCrypto\"] = factory();\n\telse\n\t\troot[\"JsCrypto\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/lib/index.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Utf8 } from \"./lib/encoder/Utf8\";\r\nexport class Hmac {\r\n    constructor(hasher, key) {\r\n        this._hasher = hasher;\r\n        // Convert string to WordArray, else assume WordArray already\r\n        if (typeof key == \"string\") {\r\n            key = Utf8.parse(key);\r\n        }\r\n        const hasherBlockSize = hasher.blockSize;\r\n        const hasherBlockSizeBytes = hasherBlockSize * 4;\r\n        // Allow arbitrary length keys\r\n        if (key.nSigBytes > hasherBlockSizeBytes) {\r\n            key = hasher.finalize(key);\r\n        }\r\n        // Clamp excess bits\r\n        key.clamp();\r\n        const oKey = this._oKey = key.clone();\r\n        const iKey = this._iKey = key.clone();\r\n        const oKeyWords = oKey.words;\r\n        const iKeyWords = iKey.words;\r\n        for (let i = 0; i < hasherBlockSize; i++) {\r\n            oKeyWords[i] ^= 0x5c5c5c5c;\r\n            iKeyWords[i] ^= 0x36363636;\r\n        }\r\n        iKey.nSigBytes = hasherBlockSizeBytes;\r\n        oKey.nSigBytes = hasherBlockSizeBytes;\r\n        // Set initial values\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets this Hmac to its initial state.\r\n     *\r\n     * @example\r\n     *   hmacHasher.reset();\r\n     */\r\n    reset() {\r\n        this._hasher.reset();\r\n        this._hasher.update(this._iKey);\r\n    }\r\n    /**\r\n     * Updates this Hmac with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hmac} This Hmac instance.\r\n     * @example\r\n     *   hmacHasher.update('message');\r\n     *   hmacHasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._hasher.update(messageUpdate);\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the Hmac computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The Hmac.\r\n     * @example\r\n     *   var hmac = hmacHasher.finalize();\r\n     *   var hmac = hmacHasher.finalize('message');\r\n     *   var hmac = hmacHasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        const innerHash = this._hasher.finalize(messageUpdate);\r\n        this._hasher.reset();\r\n        return this._hasher.finalize(this._oKey.clone().concat(innerHash));\r\n    }\r\n}\r\n","import { Word32Array } from \"./lib/Word32Array\";\r\nimport { Hasher } from \"./lib/algorithm/Hasher\";\r\n// Constants table\r\nconst T = [];\r\n(function computeConstant() {\r\n    for (let i = 0; i < 64; i++) {\r\n        T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\r\n    }\r\n})();\r\nfunction FF(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & c) | (~b & d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction GG(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & d) | (c & ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction HH(a, b, c, d, x, s, t) {\r\n    const n = a + (b ^ c ^ d) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction II(a, b, c, d, x, s, t) {\r\n    const n = a + (c ^ (b | ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\n/**\r\n * MD5 hash algorithm\r\n */\r\nexport class MD5 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Swap endian\r\n        for (let i = 0; i < 16; i++) {\r\n            // Shortcuts\r\n            const offsetI = offset + i;\r\n            const wordsOffsetI = words[offsetI];\r\n            words[offsetI] = ((((wordsOffsetI << 8) | (wordsOffsetI >>> 24)) & 0x00ff00ff)\r\n                | (((wordsOffsetI << 24) | (wordsOffsetI >>> 8)) & 0xff00ff00));\r\n        }\r\n        // Shortcuts\r\n        const H = this._hash.words;\r\n        const wordOffset0 = words[offset];\r\n        const wordOffset1 = words[offset + 1];\r\n        const wordOffset2 = words[offset + 2];\r\n        const wordOffset3 = words[offset + 3];\r\n        const wordOffset4 = words[offset + 4];\r\n        const wordOffset5 = words[offset + 5];\r\n        const wordOffset6 = words[offset + 6];\r\n        const wordOffset7 = words[offset + 7];\r\n        const wordOffset8 = words[offset + 8];\r\n        const wordOffset9 = words[offset + 9];\r\n        const wordOffset10 = words[offset + 10];\r\n        const wordOffset11 = words[offset + 11];\r\n        const wordOffset12 = words[offset + 12];\r\n        const wordOffset13 = words[offset + 13];\r\n        const wordOffset14 = words[offset + 14];\r\n        const wordOffset15 = words[offset + 15];\r\n        // Working variables\r\n        let a = H[0];\r\n        let b = H[1];\r\n        let c = H[2];\r\n        let d = H[3];\r\n        // Computation\r\n        a = FF(a, b, c, d, wordOffset0, 7, T[0]);\r\n        d = FF(d, a, b, c, wordOffset1, 12, T[1]);\r\n        c = FF(c, d, a, b, wordOffset2, 17, T[2]);\r\n        b = FF(b, c, d, a, wordOffset3, 22, T[3]);\r\n        a = FF(a, b, c, d, wordOffset4, 7, T[4]);\r\n        d = FF(d, a, b, c, wordOffset5, 12, T[5]);\r\n        c = FF(c, d, a, b, wordOffset6, 17, T[6]);\r\n        b = FF(b, c, d, a, wordOffset7, 22, T[7]);\r\n        a = FF(a, b, c, d, wordOffset8, 7, T[8]);\r\n        d = FF(d, a, b, c, wordOffset9, 12, T[9]);\r\n        c = FF(c, d, a, b, wordOffset10, 17, T[10]);\r\n        b = FF(b, c, d, a, wordOffset11, 22, T[11]);\r\n        a = FF(a, b, c, d, wordOffset12, 7, T[12]);\r\n        d = FF(d, a, b, c, wordOffset13, 12, T[13]);\r\n        c = FF(c, d, a, b, wordOffset14, 17, T[14]);\r\n        b = FF(b, c, d, a, wordOffset15, 22, T[15]);\r\n        a = GG(a, b, c, d, wordOffset1, 5, T[16]);\r\n        d = GG(d, a, b, c, wordOffset6, 9, T[17]);\r\n        c = GG(c, d, a, b, wordOffset11, 14, T[18]);\r\n        b = GG(b, c, d, a, wordOffset0, 20, T[19]);\r\n        a = GG(a, b, c, d, wordOffset5, 5, T[20]);\r\n        d = GG(d, a, b, c, wordOffset10, 9, T[21]);\r\n        c = GG(c, d, a, b, wordOffset15, 14, T[22]);\r\n        b = GG(b, c, d, a, wordOffset4, 20, T[23]);\r\n        a = GG(a, b, c, d, wordOffset9, 5, T[24]);\r\n        d = GG(d, a, b, c, wordOffset14, 9, T[25]);\r\n        c = GG(c, d, a, b, wordOffset3, 14, T[26]);\r\n        b = GG(b, c, d, a, wordOffset8, 20, T[27]);\r\n        a = GG(a, b, c, d, wordOffset13, 5, T[28]);\r\n        d = GG(d, a, b, c, wordOffset2, 9, T[29]);\r\n        c = GG(c, d, a, b, wordOffset7, 14, T[30]);\r\n        b = GG(b, c, d, a, wordOffset12, 20, T[31]);\r\n        a = HH(a, b, c, d, wordOffset5, 4, T[32]);\r\n        d = HH(d, a, b, c, wordOffset8, 11, T[33]);\r\n        c = HH(c, d, a, b, wordOffset11, 16, T[34]);\r\n        b = HH(b, c, d, a, wordOffset14, 23, T[35]);\r\n        a = HH(a, b, c, d, wordOffset1, 4, T[36]);\r\n        d = HH(d, a, b, c, wordOffset4, 11, T[37]);\r\n        c = HH(c, d, a, b, wordOffset7, 16, T[38]);\r\n        b = HH(b, c, d, a, wordOffset10, 23, T[39]);\r\n        a = HH(a, b, c, d, wordOffset13, 4, T[40]);\r\n        d = HH(d, a, b, c, wordOffset0, 11, T[41]);\r\n        c = HH(c, d, a, b, wordOffset3, 16, T[42]);\r\n        b = HH(b, c, d, a, wordOffset6, 23, T[43]);\r\n        a = HH(a, b, c, d, wordOffset9, 4, T[44]);\r\n        d = HH(d, a, b, c, wordOffset12, 11, T[45]);\r\n        c = HH(c, d, a, b, wordOffset15, 16, T[46]);\r\n        b = HH(b, c, d, a, wordOffset2, 23, T[47]);\r\n        a = II(a, b, c, d, wordOffset0, 6, T[48]);\r\n        d = II(d, a, b, c, wordOffset7, 10, T[49]);\r\n        c = II(c, d, a, b, wordOffset14, 15, T[50]);\r\n        b = II(b, c, d, a, wordOffset5, 21, T[51]);\r\n        a = II(a, b, c, d, wordOffset12, 6, T[52]);\r\n        d = II(d, a, b, c, wordOffset3, 10, T[53]);\r\n        c = II(c, d, a, b, wordOffset10, 15, T[54]);\r\n        b = II(b, c, d, a, wordOffset1, 21, T[55]);\r\n        a = II(a, b, c, d, wordOffset8, 6, T[56]);\r\n        d = II(d, a, b, c, wordOffset15, 10, T[57]);\r\n        c = II(c, d, a, b, wordOffset6, 15, T[58]);\r\n        b = II(b, c, d, a, wordOffset13, 21, T[59]);\r\n        a = II(a, b, c, d, wordOffset4, 6, T[60]);\r\n        d = II(d, a, b, c, wordOffset11, 10, T[61]);\r\n        c = II(c, d, a, b, wordOffset2, 15, T[62]);\r\n        b = II(b, c, d, a, wordOffset9, 21, T[63]);\r\n        // Intermediate hash value\r\n        H[0] = (H[0] + a) | 0;\r\n        H[1] = (H[1] + b) | 0;\r\n        H[2] = (H[2] + c) | 0;\r\n        H[3] = (H[3] + d) | 0;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\r\n        const nBitsTotalL = nBitsTotal;\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));\r\n        data.nSigBytes = (dataWords.length + 1) * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Shortcuts\r\n        const hash = this._hash;\r\n        const H = hash.words;\r\n        // Swap endian\r\n        for (let i = 0; i < 4; i++) {\r\n            // Shortcut\r\n            const Hi = H[i];\r\n            H[i] = (((Hi << 8) | (Hi >>> 24)) & 0x00ff00ff)\r\n                | (((Hi << 24) | (Hi >>> 8)) & 0xff00ff00);\r\n        }\r\n        // Return final computed hash\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new MD5(props);\r\n    }\r\n    static hash(message) {\r\n        return new MD5().finalize(message);\r\n    }\r\n}\r\n","import { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word32Array } from \"./lib/Word32Array\";\r\n// Reusable object\r\nconst W = [];\r\nexport class SHA1 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476,\r\n            0xc3d2e1f0\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476,\r\n            0xc3d2e1f0\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        const H = this._hash.words;\r\n        // Working variables\r\n        let a = H[0];\r\n        let b = H[1];\r\n        let c = H[2];\r\n        let d = H[3];\r\n        let e = H[4];\r\n        // Computation\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 16) {\r\n                W[i] = words[offset + i] | 0;\r\n            }\r\n            else {\r\n                const n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n                W[i] = (n << 1) | (n >>> 31);\r\n            }\r\n            let t = ((a << 5) | (a >>> 27)) + e + W[i];\r\n            if (i < 20) {\r\n                t += ((b & c) | (~b & d)) + 0x5a827999;\r\n            }\r\n            else if (i < 40) {\r\n                t += (b ^ c ^ d) + 0x6ed9eba1;\r\n            }\r\n            else if (i < 60) {\r\n                t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\r\n            }\r\n            else /* if (i < 80) */ {\r\n                t += (b ^ c ^ d) - 0x359d3e2a;\r\n            }\r\n            e = d;\r\n            d = c;\r\n            c = (b << 30) | (b >>> 2);\r\n            b = a;\r\n            a = t;\r\n        }\r\n        // Intermediate hash value\r\n        H[0] = (H[0] + a) | 0;\r\n        H[1] = (H[1] + b) | 0;\r\n        H[2] = (H[2] + c) | 0;\r\n        H[3] = (H[3] + d) | 0;\r\n        H[4] = (H[4] + e) | 0;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const dataWords = this._data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = this._data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\r\n        this._data.nSigBytes = dataWords.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Return final computed hash\r\n        return this._hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA1(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA1(props).finalize(message);\r\n    }\r\n}\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { random } from \"./random\";\r\n/**\r\n * An array of 32bit words\r\n */\r\nexport class Word32Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 4;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this);\r\n        }\r\n        return encoder.stringify(this);\r\n    }\r\n    /**\r\n     * Concatenates a word array to this word array.\r\n     *\r\n     * @param {Word32Array} w The word array to append.\r\n     * @return {Word32Array} This word array.\r\n     * @example\r\n     *   wordArray1.concat(wordArray2);\r\n     */\r\n    concat(w) {\r\n        const words = w.words.slice();\r\n        const N = w.nSigBytes;\r\n        this.clamp();\r\n        if (this._nSignificantBytes % 4) {\r\n            // Copy one byte at a time\r\n            for (let i = 0; i < N; i++) {\r\n                const b = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n                this._words[(this._nSignificantBytes + i) >>> 2] |= b << (24 - ((this._nSignificantBytes + i) % 4) * 8);\r\n            }\r\n        }\r\n        else {\r\n            // Copy one word at a time\r\n            for (let i = 0; i < N; i += 4) {\r\n                this._words[(this._nSignificantBytes + i) >>> 2] = words[i >>> 2];\r\n            }\r\n        }\r\n        this._nSignificantBytes += N;\r\n        // Chainable\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes insignificant bits.\r\n     *\r\n     * @example\r\n     *   wordArray.clamp();\r\n     */\r\n    clamp() {\r\n        const n = this._nSignificantBytes;\r\n        this._words[n >>> 2] &= 0xffffffff << (32 - (n % 4) * 8);\r\n        this._words.length = Math.ceil(n / 4);\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word32Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        return new Word32Array(this._words.slice(), this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Creates a word array filled with random bytes.\r\n     *\r\n     * @param {number} nBytes The number of random bytes to generate.\r\n     * @return {Word32Array} The random word array.\r\n     * @static\r\n     * @example\r\n     *   var wordArray = CryptoJS.lib.WordArray.random(16);\r\n     */\r\n    static random(nBytes) {\r\n        const words = [];\r\n        for (let i = 0; i < nBytes; i++) {\r\n            words.push(random());\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n}\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { Word32Array } from \"./Word32Array\";\r\nexport class Word64 {\r\n    constructor(high, low) {\r\n        this.high = high;\r\n        this.low = low;\r\n    }\r\n    clone() {\r\n        return new Word64(this.high, this.low);\r\n    }\r\n}\r\n/**\r\n * An array of 64bit words\r\n */\r\nexport class Word64Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 8;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this 64-bit word array to a 32-bit word array.\r\n     *\r\n     * @return {Word32Array} This word array's data as a 32-bit word array.\r\n     *\r\n     * @example\r\n     *\r\n     *     var x32WordArray = x64WordArray.toX32();\r\n     */\r\n    to32() {\r\n        const words32 = [];\r\n        for (let i = 0; i < this._words.length; i++) {\r\n            const word64 = this._words[i];\r\n            words32.push(word64.high);\r\n            words32.push(word64.low);\r\n        }\r\n        return new Word32Array(words32, this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this.to32());\r\n        }\r\n        return encoder.stringify(this.to32());\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word64Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        const words = this._words.slice();\r\n        for (let i = 0; i < words.length; i++) {\r\n            words[i] = words[i].clone();\r\n        }\r\n        return new Word64Array(words, this._nSignificantBytes);\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nimport { Utf8 } from \"../encoder/Utf8\";\r\nexport class BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        this._minBufferSize = 0;\r\n        this._blockSize = 0;\r\n        this._props = props;\r\n        this._data = props && typeof props.data !== \"undefined\" ? props.data.clone() : new Word32Array();\r\n        this._nBytes = props && typeof props.nBytes === \"number\" ? props.nBytes : 0;\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *   bufferedBlockAlgorithm.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        this._data = typeof data !== \"undefined\" ? data.clone() : new Word32Array();\r\n        this._nBytes = typeof nBytes === \"number\" ? nBytes : 0;\r\n    }\r\n    /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {Word32Array|string} data The data to append. Strings are converted to a WordArray using UTF-8.\r\n     * @example\r\n     *   bufferedBlockAlgorithm.append('data');\r\n     *   bufferedBlockAlgorithm.append(wordArray);\r\n     */\r\n    _append(data) {\r\n        const d = typeof data === \"string\" ? Utf8.parse(data) : data;\r\n        this._data.concat(d);\r\n        this._nBytes += d.nSigBytes;\r\n    }\r\n    /**\r\n     * Processes available data blocks.\r\n     * This method invokes doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean?} doFlush Whether all blocks and partial blocks should be processed.\r\n     * @return {Word32Array} The processed data.\r\n     * @example\r\n     *   var processedData = bufferedBlockAlgorithm.process();\r\n     *   var processedData = bufferedBlockAlgorithm.process(!!'flush');\r\n     */\r\n    _process(doFlush) {\r\n        let processedWords;\r\n        const words = this._data.words;\r\n        const nSigBytes = this._data.nSigBytes;\r\n        const blockSize = this._blockSize;\r\n        const blockSizeByte = this._blockSize * 4;\r\n        let nBlocksReady = nSigBytes / blockSizeByte;\r\n        if (doFlush) {\r\n            // Round up to include partial blocks\r\n            nBlocksReady = Math.ceil(nBlocksReady);\r\n        }\r\n        else {\r\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n        }\r\n        // Count words ready\r\n        const nWordsReady = nBlocksReady * blockSize;\r\n        // Count bytes ready\r\n        const nBytesReady = Math.min(nWordsReady * 4, nSigBytes);\r\n        // Process blocks\r\n        if (nWordsReady) {\r\n            for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n                // Perform concrete-algorithm logic\r\n                this._doProcessBlock(words, offset);\r\n            }\r\n            // Remove processed words\r\n            processedWords = words.splice(0, nWordsReady);\r\n            this._data.nSigBytes -= nBytesReady;\r\n        }\r\n        // Return processed words\r\n        return new Word32Array(processedWords, nBytesReady);\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"./BufferedBlockAlgorithm\";\r\nexport class Hasher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 512 / 32;\r\n        this._props = props;\r\n        if (props && typeof props.blockSize === \"number\") {\r\n            this._blockSize = props.blockSize;\r\n        }\r\n        this.reset(props ? props.data : undefined, props ? props.nBytes : undefined);\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this hasher to its initial state.\r\n     *\r\n     * @example\r\n     *   hasher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        // Reset data buffer\r\n        super.reset.call(this, data, nBytes);\r\n        // Perform concrete-hasher logic\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Updates this hasher with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hasher} This hasher.\r\n     * @example\r\n     *   hasher.update('message');\r\n     *   hasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._append(messageUpdate);\r\n        this._process();\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the hash computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string?} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The hash.\r\n     * @example\r\n     *   var hash = hasher.finalize();\r\n     *   var hash = hasher.finalize('message');\r\n     *   var hash = hasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        // Final message update\r\n        if (messageUpdate) {\r\n            this._append(messageUpdate);\r\n        }\r\n        // Perform concrete-hasher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\n/**\r\n * A collection of cipher parameters.\r\n *\r\n * @property {Word32Array} ciphertext The raw ciphertext.\r\n * @property {Word32Array} key The key to this ciphertext.\r\n * @property {Word32Array} iv The IV used in the ciphering operation.\r\n * @property {Word32Array} salt The salt used with a key derivation function.\r\n * @property {typeof Cipher} algorithm The cipher algorithm.\r\n * @property {BlockCipherMode} mode The block mode used in the ciphering operation.\r\n * @property {Pad} padding The padding scheme used in the ciphering operation.\r\n * @property {number} blockSize The block size of the cipher.\r\n * @property {Formatter} formatter The default formatting strategy to convert this cipher params object to a string.\r\n */\r\nexport class CipherParams {\r\n    /**\r\n     * Initializes a newly created cipher params object.\r\n     *\r\n     * @param {Partial<CipherParams>} cp An object with any of the possible cipher parameters.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.lib.CipherParams.create({\r\n     *       ciphertext: ciphertextWordArray,\r\n     *       key: keyWordArray,\r\n     *       iv: ivWordArray,\r\n     *       salt: saltWordArray,\r\n     *       algorithm: JsCrypto.AES,\r\n     *       mode: JsCrypto.CBC,\r\n     *       padding: JsCrypto.PKCS7,\r\n     *       blockSize: 4,\r\n     *       formatter: JsCrypto.OpenSSLFormatter\r\n     *     });\r\n     */\r\n    constructor(cp) {\r\n        this.formatter = OpenSSLFormatter;\r\n        if (cp) {\r\n            this.cipherText = cp.cipherText;\r\n            this.key = cp.key;\r\n            this.iv = cp.iv;\r\n            this.salt = cp.salt;\r\n            this.Algorithm = cp.Algorithm;\r\n            this.mode = cp.mode;\r\n            this.padding = cp.padding;\r\n            this.blockSize = cp.blockSize;\r\n            this.formatter = cp.formatter || OpenSSLFormatter;\r\n        }\r\n    }\r\n    /**\r\n     * Converts this cipher params object to a string.\r\n     *\r\n     * @param {Formatter?} formatter (Optional) The formatting strategy to use.\r\n     * @return {string} The stringified cipher params.\r\n     * @throws Error If neither the formatter nor the default formatter is set.\r\n     * @example\r\n     *   var string = cipherParams + '';\r\n     *   var string = cipherParams.toString();\r\n     *   var string = cipherParams.toString(CryptoJS.format.OpenSSL);\r\n     */\r\n    toString(formatter) {\r\n        return (formatter || this.formatter).stringify(this);\r\n    }\r\n}\r\n","import { CipherParams } from \"../CipherParams\";\r\nimport { Word32Array } from \"../../../Word32Array\";\r\nimport { Base64 } from \"../../../encoder/Base64\";\r\nexport const OpenSSLFormatter = {\r\n    /**\r\n     * Converts a cipher params object to an OpenSSL-compatible string.\r\n     *\r\n     * @param {CipherParams} cipherParams The cipher params object.\r\n     * @return {string} The OpenSSL-compatible string.\r\n     * @example\r\n     *   var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\r\n     */\r\n    stringify(cipherParams) {\r\n        // Shortcuts\r\n        const cipherText = cipherParams.cipherText;\r\n        const salt = cipherParams.salt;\r\n        if (!cipherText) {\r\n            return \"\";\r\n        }\r\n        // Format\r\n        if (salt) {\r\n            const wordArray = new Word32Array([0x53616c74, 0x65645f5f]).concat(salt).concat(cipherText);\r\n            return wordArray.toString(Base64);\r\n        }\r\n        return cipherText.toString(Base64);\r\n    },\r\n    /**\r\n     * Converts an OpenSSL-compatible string to a cipher params object.\r\n     *\r\n     * @param {string} openSSLStr The OpenSSL-compatible string.\r\n     * @return {CipherParams} The cipher params object.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\r\n     */\r\n    parse(openSSLStr) {\r\n        let salt;\r\n        // Parse base64\r\n        const cipherText = Base64.parse(openSSLStr);\r\n        // Shortcut\r\n        const ciphertextWords = cipherText.words;\r\n        // Test for salt\r\n        if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\r\n            // Extract salt\r\n            salt = new Word32Array(ciphertextWords.slice(2, 4));\r\n            // Remove salt from ciphertext\r\n            ciphertextWords.splice(0, 4);\r\n            cipherText.nSigBytes -= 16;\r\n        }\r\n        return new CipherParams({ cipherText, salt });\r\n    }\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\nimport { CipherParams } from \"../CipherParams\";\r\nimport { EvpKDF } from \"./module/EvpKDF\";\r\n/**\r\n * Derives a key and IV from a password.\r\n *\r\n * @param {string} password The password to derive from.\r\n * @param {number} keySize The size in words of the key to generate.\r\n * @param {number} ivSize The size in words of the IV to generate.\r\n * @param {Word32Array?} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\r\n * @return {CipherParams} A cipher params object with the key, IV, and salt.\r\n * @example\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32);\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32, 'saltsalt');\r\n */\r\nexport const OpenSSLKDF = {\r\n    execute(password, keySize, ivSize, salt, props) {\r\n        // Generate random salt\r\n        if (!salt) {\r\n            salt = Word32Array.random(64 / 8);\r\n        }\r\n        const KDFModule = props && props.KDF || EvpKDF;\r\n        const kdfProps = props ? { Hasher: props.Hasher, iterations: props.iterations } : {};\r\n        // Derive key and IV\r\n        const key = KDFModule.getKey(password, salt, Object.assign(Object.assign({}, kdfProps), { keySize: keySize + ivSize }));\r\n        // Separate key and IV\r\n        const iv = new Word32Array(key.words.slice(keySize), ivSize * 4);\r\n        key.nSigBytes = keySize * 4;\r\n        // Return params\r\n        return new CipherParams({ key, iv, salt });\r\n    }\r\n};\r\n","import { MD5 } from \"../../../../../MD5\";\r\nimport { Word32Array } from \"../../../../Word32Array\";\r\nimport { BaseKDFModule } from \"../type\";\r\n/**\r\n * This key derivation function is meant to conform with EVP_BytesToKey.\r\n * https://www.openssl.org/docs/man1.1.1/man3/EVP_BytesToKey.html\r\n *\r\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n * @property {Hasher} hasher The hash algorithm to use. Default: MD5\r\n * @property {number} iterations The number of iterations to perform. Default: 1\r\n */\r\nexport class EvpKDF extends BaseKDFModule {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keySize = 128 / 32;\r\n        this._Hasher = MD5;\r\n        this._iterations = 1;\r\n        if (props) {\r\n            this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\r\n            this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\r\n            this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\r\n        }\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @return {Word32Array} The derived key.\r\n     * @example\r\n     *   var key = kdf.compute(password, salt);\r\n     */\r\n    compute(password, salt) {\r\n        let block;\r\n        // Init hasher\r\n        const hasher = new this._Hasher();\r\n        // Initial values\r\n        const derivedKey = new Word32Array();\r\n        // Shortcuts\r\n        const derivedKeyWords = derivedKey.words;\r\n        const keySize = this._keySize;\r\n        const iterations = this._iterations;\r\n        // Generate key\r\n        while (derivedKeyWords.length < keySize) {\r\n            if (block) {\r\n                hasher.update(block);\r\n            }\r\n            block = hasher.update(password).finalize(salt);\r\n            hasher.reset();\r\n            // Iterations\r\n            for (let i = 1; i < iterations; i++) {\r\n                block = hasher.finalize(block);\r\n                hasher.reset();\r\n            }\r\n            derivedKey.concat(block);\r\n        }\r\n        derivedKey.nSigBytes = keySize * 4;\r\n        return derivedKey;\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @param {Partial<EvpKDFProps>?} props (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {Word32Array} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = EvpKDF.getKey(password, salt);\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8 });\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\r\n    static getKey(password, salt, props) {\r\n        return new EvpKDF(props).compute(password, salt);\r\n    }\r\n}\r\n","import { SHA1 } from \"../../../../../SHA1\";\r\nimport { Hmac } from \"../../../../../Hmac\";\r\nimport { Word32Array } from \"../../../../Word32Array\";\r\nimport { BaseKDFModule } from \"../type\";\r\n/**\r\n * Password-Based Key Derivation Function 2 algorithm.\r\n *\r\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n * @property {Hasher} hasher The hash algorithm to use. Default: SHA1\r\n * @property {number} iterations The number of iterations to perform. Default: 1\r\n */\r\nexport class PBKDF2 extends BaseKDFModule {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keySize = 128 / 32;\r\n        this._Hasher = SHA1;\r\n        this._iterations = 1;\r\n        if (props) {\r\n            this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\r\n            this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\r\n            this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\r\n        }\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @return {Word32Array} The derived key.\r\n     * @example\r\n     *   var key = kdf.compute(password, salt);\r\n     */\r\n    compute(password, salt) {\r\n        // Init HMAC\r\n        const hmac = new Hmac(new this._Hasher(), password);\r\n        // Initial values\r\n        const derivedKey = new Word32Array();\r\n        const blockIndex = new Word32Array([0x00000001]);\r\n        // Shortcuts\r\n        const derivedKeyWords = derivedKey.words;\r\n        const blockIndexWords = blockIndex.words;\r\n        const keySize = this._keySize;\r\n        const iterations = this._iterations;\r\n        // Generate key\r\n        while (derivedKeyWords.length < keySize) {\r\n            const block = hmac.update(salt).finalize(blockIndex);\r\n            hmac.reset();\r\n            // Shortcuts\r\n            const blockWords = block.words;\r\n            const blockWordsLength = blockWords.length;\r\n            // Iterations\r\n            let intermediate = block;\r\n            for (let i = 1; i < iterations; i++) {\r\n                intermediate = hmac.finalize(intermediate);\r\n                hmac.reset();\r\n                // Shortcut\r\n                const intermediateWords = intermediate.words;\r\n                // XOR intermediate with block\r\n                for (let j = 0; j < blockWordsLength; j++) {\r\n                    blockWords[j] ^= intermediateWords[j];\r\n                }\r\n            }\r\n            derivedKey.concat(block);\r\n            blockIndexWords[0]++;\r\n        }\r\n        derivedKey.nSigBytes = keySize * 4;\r\n        return derivedKey;\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @param {Partial<PBKDF2Props>?} props (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {Word32Array} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = PBKDF2.getKey(password, salt);\r\n     *     var key = PBKDF2.getKey(password, salt, { keySize: 8 });\r\n     *     var key = PBKDF2.getKey(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\r\n    static getKey(password, salt, props) {\r\n        return new PBKDF2(props).compute(password, salt);\r\n    }\r\n}\r\n","export class BaseKDFModule {\r\n    constructor(props) {\r\n        this._props = props;\r\n    }\r\n    compute(password, salt) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    static getKey(password, salt, props) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","const ua = typeof navigator !== \"undefined\" && navigator.userAgent ? navigator.userAgent.toLowerCase() : \"\";\r\nconst IEVer = (() => {\r\n    let ver = parseInt((/msie (\\d+)/.exec(ua) || [])[1], 10);\r\n    if (isNaN(ver)) {\r\n        ver = parseInt((/trident\\/.*; rv:(\\d+)/.exec(ua) || [])[1], 10);\r\n        if (isNaN(ver)) {\r\n            return false;\r\n        }\r\n        return ver;\r\n    }\r\n    return ver;\r\n})();\r\nexport function isIE(op, ver) {\r\n    if (IEVer === false)\r\n        return false;\r\n    if (!ver)\r\n        return true;\r\n    if (op === \"<\")\r\n        return IEVer < ver;\r\n    if (op === \"<=\")\r\n        return IEVer <= ver;\r\n    if (op === \">\")\r\n        return IEVer > ver;\r\n    if (op === \">=\")\r\n        return IEVer >= ver;\r\n    if (op === \"=\")\r\n        return IEVer === ver;\r\n    return IEVer === ver;\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nconst map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst reverseMap = [];\r\nfor (let i = 0; i < map.length; i++) {\r\n    reverseMap[map.charCodeAt(i)] = i;\r\n}\r\nexport const Base64 = {\r\n    /**\r\n     * Converts a word array to a base64 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The base64 string.\r\n     * @example\r\n     *   var hexString = Base64.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Clamp excess bits\r\n        w.clamp();\r\n        // Convert\r\n        const base64Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 3) {\r\n            const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\r\n            const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\r\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\r\n            for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\r\n                base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\r\n            }\r\n        }\r\n        // Add padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            while (base64Chars.length % 4) {\r\n                base64Chars.push(paddingChar);\r\n            }\r\n        }\r\n        return base64Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a base64 string to a word array.\r\n     *\r\n     * @param {string} base64Str The base64 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Base64.parse(base64String);\r\n     */\r\n    parse(base64Str) {\r\n        let base64StrLength = base64Str.length;\r\n        // Ignore padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            const paddingIndex = base64Str.indexOf(paddingChar);\r\n            if (paddingIndex !== -1) {\r\n                base64StrLength = paddingIndex;\r\n            }\r\n        }\r\n        const words = [];\r\n        let nBytes = 0;\r\n        for (let i = 0; i < base64StrLength; i++) {\r\n            if (i % 4) {\r\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\r\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\r\n                const bitsCombined = bits1 | bits2;\r\n                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\r\n                nBytes++;\r\n            }\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Hex = {\r\n    /**\r\n     * Converts a word array to a hex string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The hex string.\r\n     * @example\r\n     *   var hexString = Hex.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const hexChars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            hexChars.push((byte >>> 4).toString(16));\r\n            hexChars.push((byte & 0x0f).toString(16));\r\n        }\r\n        return hexChars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a hex string to a word array.\r\n     *\r\n     * @param {string} hexStr The hex string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Hex.parse(hexString);\r\n     */\r\n    parse(hexStr) {\r\n        const Len = hexStr.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i += 2) {\r\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\r\n        }\r\n        return new Word32Array(words, Len / 2);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Latin1 = {\r\n    /**\r\n     * Converts a word array to a Latin1 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The Latin1 string.\r\n     * @example\r\n     *   var latin1String = Latin1.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const latin1Chars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            latin1Chars.push(String.fromCharCode(byte));\r\n        }\r\n        return latin1Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a latin1 string to a word array.\r\n     *\r\n     * @param {string} latin1Str The latin1 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Latin1.parse(latin1Str);\r\n     */\r\n    parse(latin1Str) {\r\n        const Len = latin1Str.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i++) {\r\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\r\n        }\r\n        return new Word32Array(words, Len);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\n/**\r\n * UTF-16 BE encoding strategy.\r\n */\r\nexport const Utf16BE = {\r\n    /**\r\n     * Converts a word array to a UTF-16 BE string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-16 BE string.\r\n     * @example\r\n     *   var utf16String = Utf16.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Convert\r\n        const utf16Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 2) {\r\n            const codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\r\n            utf16Chars.push(String.fromCharCode(codePoint));\r\n        }\r\n        return utf16Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a UTF-16 BE string to a word array.\r\n     * @param {string} utf16Str The UTF-16 BE string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   const wordArray = Utf16.parse(utf16String);\r\n     */\r\n    parse(utf16Str) {\r\n        // Shortcut\r\n        const utf16StrLength = utf16Str.length;\r\n        // Convert\r\n        const words = [];\r\n        for (let i = 0; i < utf16StrLength; i++) {\r\n            words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\r\n        }\r\n        return new Word32Array(words, utf16StrLength * 2);\r\n    }\r\n};\r\nfunction swapEndian(word) {\r\n    return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\r\n}\r\n/**\r\n * UTF-16 LE encoding strategy.\r\n */\r\nexport const Utf16LE = {\r\n    /**\r\n     * Converts a word array to a UTF-16 LE string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-16 LE string.\r\n     * @example\r\n     *   var utf16String = Utf16.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Convert\r\n        const utf16Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 2) {\r\n            const codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\r\n            utf16Chars.push(String.fromCharCode(codePoint));\r\n        }\r\n        return utf16Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a UTF-16 LE string to a word array.\r\n     * @param {string} utf16Str The UTF-16 LE string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   const wordArray = Utf16.parse(utf16String);\r\n     */\r\n    parse(utf16Str) {\r\n        // Shortcut\r\n        const utf16StrLength = utf16Str.length;\r\n        // Convert\r\n        const words = [];\r\n        for (let i = 0; i < utf16StrLength; i++) {\r\n            words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\r\n        }\r\n        return new Word32Array(words, utf16StrLength * 2);\r\n    }\r\n};\r\nexport const Utf16 = Utf16BE;\r\n","import { Latin1 } from \"./Latin1\";\r\nexport const Utf8 = {\r\n    /**\r\n     * Converts a word array to a UTF-8 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-8 string.\r\n     * @example\r\n     *   var utf8String = Utf8.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        try {\r\n            return decodeURIComponent(escape(Latin1.stringify(w)));\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Malformed UTF-8 data\");\r\n        }\r\n    },\r\n    /**\r\n     * Converts a UTF-8 string to a word array.\r\n     *\r\n     * @param {string} utf8Str The UTF-8 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Utf8.parse(utf8Str);\r\n     */\r\n    parse(utf8Str) {\r\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\r\n    }\r\n};\r\n","export { random } from \"./random\";\r\nexport { Word32Array } from \"./Word32Array\";\r\nexport { Word64, Word64Array } from \"./Word64Array\";\r\nexport { isIE } from \"./browser\";\r\nexport { Base64 } from \"./encoder/Base64\";\r\nexport { Utf8 } from \"./encoder/Utf8\";\r\nexport { Latin1 } from \"./encoder/Latin1\";\r\nexport { Hex } from \"./encoder/Hex\";\r\nexport { Utf16BE, Utf16LE, Utf16 } from \"./encoder/Utf16\";\r\nexport { OpenSSLKDF } from \"./algorithm/cipher/kdf/OpenSSLKDF\";\r\nexport { PBKDF2 } from \"./algorithm/cipher/kdf/module/PBKDF2\";\r\nexport { EvpKDF } from \"./algorithm/cipher/kdf/module/EvpKDF\";\r\n","function makeRandFunction() {\r\n    if (typeof window !== \"undefined\") {\r\n        const c = window.crypto || window.msCrypto;\r\n        if (!c) {\r\n            throw new Error(\"Crypto module not found\");\r\n        }\r\n        return function rand() {\r\n            return c.getRandomValues(new Uint32Array(1))[0];\r\n        };\r\n    }\r\n    else if (typeof global !== \"undefined\" && global.crypto) {\r\n        return function rand() {\r\n            return global.crypto.randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    else if (typeof require === \"function\") {\r\n        return function rand() {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore\r\n            return __non_webpack_require__(\"crypto\").randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    throw new Error(\"Unable to find crypto module\");\r\n}\r\nexport const random = makeRandFunction();\r\n"],"sourceRoot":""}