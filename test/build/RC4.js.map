{"version":3,"sources":["webpack://JsCrypto/webpack/universalModuleDefinition","webpack://JsCrypto/webpack/bootstrap","webpack://JsCrypto/(webpack)/buildin/global.js","webpack://JsCrypto/./src/MD5.ts","webpack://JsCrypto/./src/RC4.ts","webpack://JsCrypto/./src/lib/Word32Array.ts","webpack://JsCrypto/./src/lib/algorithm/BufferedBlockAlgorithm.ts","webpack://JsCrypto/./src/lib/algorithm/Hasher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/Cipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/CipherParams.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/PasswordBasedCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/SerializableCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/StreamCipher.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/formatter/OpenSSLFormatter.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/OpenSSLKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/module/EvpKDF.ts","webpack://JsCrypto/./src/lib/algorithm/cipher/kdf/type.ts","webpack://JsCrypto/./src/lib/encoder/Base64.ts","webpack://JsCrypto/./src/lib/encoder/Hex.ts","webpack://JsCrypto/./src/lib/encoder/Latin1.ts","webpack://JsCrypto/./src/lib/encoder/Utf8.ts","webpack://JsCrypto/./src/lib/random.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAgD;AACA;AAChD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,4DAAM;AAC/B;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAA;AAAmE;AACc;AACF;AACxE,kBAAkB,+EAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,MAAM;AACtE;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA,iDAAiD;AACjD,qDAAqD,WAAW,MAAM;AACtE;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAmB;AACtC;AACA,eAAe,2FAAkB;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAoC;AACF;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,uBAAuB,sDAAM;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAA6C;AACN;AAChC;AACP;AACA;AACA;AACA;AACA,2FAA2F,wDAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wDAAW;AACjF;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAkE;AAC3D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAmE;AAC5D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,gDAAgD;AACnH;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,sBAAsB;AACrC,gBAAgB,OAAO;AACvB;AACA,uEAAuE,kBAAkB;AACzF;AACA;AACA,iDAAiD;AACjD,wDAAwD,WAAW,gDAAgD;AACnH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAgE;AAChE;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;AACO;AACP;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,4EAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4EAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4E;AAC9B;AACA;AACkB;AACzD;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,mBAAmB;AAClC,eAAe,OAAO;AACtB,eAAe,mCAAmC;AAClD,gBAAgB,aAAa;AAC7B;AACA;AACA,+FAA+F,oCAAoC;AACnI;AACA;AACA,0CAA0C;AAC1C,qDAAqD,0DAAU;AAC/D;AACA;AACA,6BAA6B,sEAAkB;AAC/C,mBAAmB,0DAAY,+BAA+B,kBAAkB,yEAAyE;AACzJ,KAAK;AACL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB,eAAe,mCAAmC;AAClD,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0CAA0C;AAC1C,oCAAoC,0DAAU;AAC9C,sDAAsD,4EAAgB;AACtE,iCAAiC,2EAAe;AAChD;AACA;AACA,eAAe,sEAAkB;AACjC;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAgE;AAClB;AAC9C;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,UAAU;AACrB,YAAY,aAAa;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,mBAAmB;AAClC,eAAe,YAAY;AAC3B,eAAe,kCAAkC;AACjD,gBAAgB,aAAa;AAC7B;AACA;AACA,iGAAiG,SAAS;AAC1G;AACA;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,4EAAgB;AAC1G,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,oBAAoB;AACnC,eAAe,YAAY;AAC3B,eAAe,iCAAiC;AAChD,gBAAgB,YAAY;AAC5B;AACA,wGAAwG,mCAAmC;AAC3I,qGAAqG,mCAAmC;AACxI;AACA;AACA;AACA,4HAA4H,4EAAgB;AAC5I;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAkC;AAC3B,2BAA2B,8CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACI;AACF;AAC1C;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C,sCAAsC,sDAAM;AAC5C;AACA,mCAAmC,sDAAM;AACzC,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAM;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA;AACA,mBAAmB,0DAAY,EAAE,mBAAmB;AACpD;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACJ;AACN;AACzC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA,gDAAgD,qDAAM;AACtD,kCAAkC,qDAAqD;AACvF;AACA,mFAAmF,cAAc,4BAA4B;AAC7H;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA,mBAAmB,0DAAY,EAAE,gBAAgB;AACjD;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACa;AACd;AACxC;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO,qBAAqB,mDAAa;AACzC;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC,eAAe,sBAAsB;AACrC;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAA6C;AAC7C;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAkC;AAC3B;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAM;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAA6B;AAC1C;AACA;AACA;AACA,mBAAmB,OAAuB;AAC1C;AACA;AACA;AACA;AACO","file":"RC4.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsCrypto\"] = factory();\n\telse\n\t\troot[\"JsCrypto\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/RC4.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Word32Array } from \"./lib/Word32Array\";\r\nimport { Hasher } from \"./lib/algorithm/Hasher\";\r\n// Constants table\r\nconst T = [];\r\n(function computeConstant() {\r\n    for (let i = 0; i < 64; i++) {\r\n        T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\r\n    }\r\n})();\r\nfunction FF(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & c) | (~b & d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction GG(a, b, c, d, x, s, t) {\r\n    const n = a + ((b & d) | (c & ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction HH(a, b, c, d, x, s, t) {\r\n    const n = a + (b ^ c ^ d) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\nfunction II(a, b, c, d, x, s, t) {\r\n    const n = a + (c ^ (b | ~d)) + x + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n}\r\n/**\r\n * MD5 hash algorithm\r\n */\r\nexport class MD5 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word32Array([\r\n            0x67452301, 0xefcdab89,\r\n            0x98badcfe, 0x10325476\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Swap endian\r\n        for (let i = 0; i < 16; i++) {\r\n            // Shortcuts\r\n            const offsetI = offset + i;\r\n            const wordsOffsetI = words[offsetI];\r\n            words[offsetI] = ((((wordsOffsetI << 8) | (wordsOffsetI >>> 24)) & 0x00ff00ff)\r\n                | (((wordsOffsetI << 24) | (wordsOffsetI >>> 8)) & 0xff00ff00));\r\n        }\r\n        // Shortcuts\r\n        const H = this._hash.words;\r\n        const wordOffset0 = words[offset];\r\n        const wordOffset1 = words[offset + 1];\r\n        const wordOffset2 = words[offset + 2];\r\n        const wordOffset3 = words[offset + 3];\r\n        const wordOffset4 = words[offset + 4];\r\n        const wordOffset5 = words[offset + 5];\r\n        const wordOffset6 = words[offset + 6];\r\n        const wordOffset7 = words[offset + 7];\r\n        const wordOffset8 = words[offset + 8];\r\n        const wordOffset9 = words[offset + 9];\r\n        const wordOffset10 = words[offset + 10];\r\n        const wordOffset11 = words[offset + 11];\r\n        const wordOffset12 = words[offset + 12];\r\n        const wordOffset13 = words[offset + 13];\r\n        const wordOffset14 = words[offset + 14];\r\n        const wordOffset15 = words[offset + 15];\r\n        // Working variables\r\n        let a = H[0];\r\n        let b = H[1];\r\n        let c = H[2];\r\n        let d = H[3];\r\n        // Computation\r\n        a = FF(a, b, c, d, wordOffset0, 7, T[0]);\r\n        d = FF(d, a, b, c, wordOffset1, 12, T[1]);\r\n        c = FF(c, d, a, b, wordOffset2, 17, T[2]);\r\n        b = FF(b, c, d, a, wordOffset3, 22, T[3]);\r\n        a = FF(a, b, c, d, wordOffset4, 7, T[4]);\r\n        d = FF(d, a, b, c, wordOffset5, 12, T[5]);\r\n        c = FF(c, d, a, b, wordOffset6, 17, T[6]);\r\n        b = FF(b, c, d, a, wordOffset7, 22, T[7]);\r\n        a = FF(a, b, c, d, wordOffset8, 7, T[8]);\r\n        d = FF(d, a, b, c, wordOffset9, 12, T[9]);\r\n        c = FF(c, d, a, b, wordOffset10, 17, T[10]);\r\n        b = FF(b, c, d, a, wordOffset11, 22, T[11]);\r\n        a = FF(a, b, c, d, wordOffset12, 7, T[12]);\r\n        d = FF(d, a, b, c, wordOffset13, 12, T[13]);\r\n        c = FF(c, d, a, b, wordOffset14, 17, T[14]);\r\n        b = FF(b, c, d, a, wordOffset15, 22, T[15]);\r\n        a = GG(a, b, c, d, wordOffset1, 5, T[16]);\r\n        d = GG(d, a, b, c, wordOffset6, 9, T[17]);\r\n        c = GG(c, d, a, b, wordOffset11, 14, T[18]);\r\n        b = GG(b, c, d, a, wordOffset0, 20, T[19]);\r\n        a = GG(a, b, c, d, wordOffset5, 5, T[20]);\r\n        d = GG(d, a, b, c, wordOffset10, 9, T[21]);\r\n        c = GG(c, d, a, b, wordOffset15, 14, T[22]);\r\n        b = GG(b, c, d, a, wordOffset4, 20, T[23]);\r\n        a = GG(a, b, c, d, wordOffset9, 5, T[24]);\r\n        d = GG(d, a, b, c, wordOffset14, 9, T[25]);\r\n        c = GG(c, d, a, b, wordOffset3, 14, T[26]);\r\n        b = GG(b, c, d, a, wordOffset8, 20, T[27]);\r\n        a = GG(a, b, c, d, wordOffset13, 5, T[28]);\r\n        d = GG(d, a, b, c, wordOffset2, 9, T[29]);\r\n        c = GG(c, d, a, b, wordOffset7, 14, T[30]);\r\n        b = GG(b, c, d, a, wordOffset12, 20, T[31]);\r\n        a = HH(a, b, c, d, wordOffset5, 4, T[32]);\r\n        d = HH(d, a, b, c, wordOffset8, 11, T[33]);\r\n        c = HH(c, d, a, b, wordOffset11, 16, T[34]);\r\n        b = HH(b, c, d, a, wordOffset14, 23, T[35]);\r\n        a = HH(a, b, c, d, wordOffset1, 4, T[36]);\r\n        d = HH(d, a, b, c, wordOffset4, 11, T[37]);\r\n        c = HH(c, d, a, b, wordOffset7, 16, T[38]);\r\n        b = HH(b, c, d, a, wordOffset10, 23, T[39]);\r\n        a = HH(a, b, c, d, wordOffset13, 4, T[40]);\r\n        d = HH(d, a, b, c, wordOffset0, 11, T[41]);\r\n        c = HH(c, d, a, b, wordOffset3, 16, T[42]);\r\n        b = HH(b, c, d, a, wordOffset6, 23, T[43]);\r\n        a = HH(a, b, c, d, wordOffset9, 4, T[44]);\r\n        d = HH(d, a, b, c, wordOffset12, 11, T[45]);\r\n        c = HH(c, d, a, b, wordOffset15, 16, T[46]);\r\n        b = HH(b, c, d, a, wordOffset2, 23, T[47]);\r\n        a = II(a, b, c, d, wordOffset0, 6, T[48]);\r\n        d = II(d, a, b, c, wordOffset7, 10, T[49]);\r\n        c = II(c, d, a, b, wordOffset14, 15, T[50]);\r\n        b = II(b, c, d, a, wordOffset5, 21, T[51]);\r\n        a = II(a, b, c, d, wordOffset12, 6, T[52]);\r\n        d = II(d, a, b, c, wordOffset3, 10, T[53]);\r\n        c = II(c, d, a, b, wordOffset10, 15, T[54]);\r\n        b = II(b, c, d, a, wordOffset1, 21, T[55]);\r\n        a = II(a, b, c, d, wordOffset8, 6, T[56]);\r\n        d = II(d, a, b, c, wordOffset15, 10, T[57]);\r\n        c = II(c, d, a, b, wordOffset6, 15, T[58]);\r\n        b = II(b, c, d, a, wordOffset13, 21, T[59]);\r\n        a = II(a, b, c, d, wordOffset4, 6, T[60]);\r\n        d = II(d, a, b, c, wordOffset11, 10, T[61]);\r\n        c = II(c, d, a, b, wordOffset2, 15, T[62]);\r\n        b = II(b, c, d, a, wordOffset9, 21, T[63]);\r\n        // Intermediate hash value\r\n        H[0] = (H[0] + a) | 0;\r\n        H[1] = (H[1] + b) | 0;\r\n        H[2] = (H[2] + c) | 0;\r\n        H[3] = (H[3] + d) | 0;\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\r\n        const nBitsTotalL = nBitsTotal;\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));\r\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\r\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));\r\n        data.nSigBytes = (dataWords.length + 1) * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Shortcuts\r\n        const hash = this._hash;\r\n        const H = hash.words;\r\n        // Swap endian\r\n        for (let i = 0; i < 4; i++) {\r\n            // Shortcut\r\n            const Hi = H[i];\r\n            H[i] = (((Hi << 8) | (Hi >>> 24)) & 0x00ff00ff)\r\n                | (((Hi << 24) | (Hi >>> 8)) & 0xff00ff00);\r\n        }\r\n        // Return final computed hash\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new MD5(props);\r\n    }\r\n    static hash(message) {\r\n        return new MD5().finalize(message);\r\n    }\r\n}\r\n","import { StreamCipher } from \"./lib/algorithm/cipher/StreamCipher\";\r\nimport { PasswordBasedCipher } from \"./lib/algorithm/cipher/PasswordBasedCipher\";\r\nimport { SerializableCipher } from \"./lib/algorithm/cipher/SerializableCipher\";\r\nexport class RC4 extends StreamCipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this.S = [];\r\n        this.i = 0;\r\n        this.j = 0;\r\n        this._props = props;\r\n        this._doReset();\r\n    }\r\n    _doReset() {\r\n        // Shortcuts\r\n        const key = this._key;\r\n        const keyWords = key.words;\r\n        const keySigBytes = key.nSigBytes;\r\n        // Init sbox\r\n        this.S = [];\r\n        for (let i = 0; i < 256; i++) {\r\n            this.S[i] = i;\r\n        }\r\n        // Key setup\r\n        for (let i = 0, j = 0; i < 256; i++) {\r\n            const keyByteIndex = i % keySigBytes;\r\n            const keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\r\n            j = (j + this.S[i] + keyByte) % 256;\r\n            // Swap\r\n            const t = this.S[i];\r\n            this.S[i] = this.S[j];\r\n            this.S[j] = t;\r\n        }\r\n        // Counters\r\n        this.i = this.j = 0;\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        words[offset] ^= this.generateKeyStreamWord();\r\n    }\r\n    generateKeyStreamWord() {\r\n        // Shortcuts\r\n        const S = this.S;\r\n        let i = this.i;\r\n        let j = this.j;\r\n        // Generate keyStream word\r\n        let keyStreamWord = 0;\r\n        for (let n = 0; n < 4; n++) {\r\n            i = (i + 1) % 256;\r\n            j = (j + S[i]) % 256;\r\n            // Swap\r\n            const t = S[i];\r\n            S[i] = S[j];\r\n            S[j] = t;\r\n            keyStreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\r\n        }\r\n        // Update counters\r\n        this.i = i;\r\n        this.j = j;\r\n        return keyStreamWord;\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4.createEncryptor(keyWordArray);\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = JsCrypto.RC4.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new RC4(Object.assign(Object.assign({}, props), { key }));\r\n    }\r\n    /**\r\n     * Encrypt a message with key\r\n     *\r\n     * @param {Word32Array|string} message\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4.encrypt(\"test\", \"pass\");\r\n     */\r\n    static encrypt(message, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.encrypt(RC4, message, key, props);\r\n        }\r\n        return SerializableCipher.encrypt(RC4, message, key, props);\r\n    }\r\n    /**\r\n     * Encrypt a encrypted message with key\r\n     *\r\n     * @param {CipherParams} cipherText\r\n     * @param {Word32Array|string} key\r\n     * @param {Partial<AESProps>?} props\r\n     * @example\r\n     *   var encryptedMessage = JsCrypt.RC4.decrypt(cipherProps, \"pass\");\r\n     */\r\n    static decrypt(cipherText, key, props) {\r\n        if (typeof key === \"string\") {\r\n            return PasswordBasedCipher.decrypt(RC4, cipherText, key, props);\r\n        }\r\n        return SerializableCipher.decrypt(RC4, cipherText, key, props);\r\n    }\r\n}\r\nRC4.ivSize = 0;\r\nRC4.keySize = 256 / 32;\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { random } from \"./random\";\r\n/**\r\n * An array of 32bit words\r\n */\r\nexport class Word32Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 4;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this);\r\n        }\r\n        return encoder.stringify(this);\r\n    }\r\n    /**\r\n     * Concatenates a word array to this word array.\r\n     *\r\n     * @param {Word32Array} w The word array to append.\r\n     * @return {Word32Array} This word array.\r\n     * @example\r\n     *   wordArray1.concat(wordArray2);\r\n     */\r\n    concat(w) {\r\n        const words = w.words.slice();\r\n        const N = w.nSigBytes;\r\n        this.clamp();\r\n        if (this._nSignificantBytes % 4) {\r\n            // Copy one byte at a time\r\n            for (let i = 0; i < N; i++) {\r\n                const b = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n                this._words[(this._nSignificantBytes + i) >>> 2] |= b << (24 - ((this._nSignificantBytes + i) % 4) * 8);\r\n            }\r\n        }\r\n        else {\r\n            // Copy one word at a time\r\n            for (let i = 0; i < N; i += 4) {\r\n                this._words[(this._nSignificantBytes + i) >>> 2] = words[i >>> 2];\r\n            }\r\n        }\r\n        this._nSignificantBytes += N;\r\n        // Chainable\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes insignificant bits.\r\n     *\r\n     * @example\r\n     *   wordArray.clamp();\r\n     */\r\n    clamp() {\r\n        const n = this._nSignificantBytes;\r\n        this._words[n >>> 2] &= 0xffffffff << (32 - (n % 4) * 8);\r\n        this._words.length = Math.ceil(n / 4);\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word32Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        return new Word32Array(this._words.slice(), this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Creates a word array filled with random bytes.\r\n     *\r\n     * @param {number} nBytes The number of random bytes to generate.\r\n     * @return {Word32Array} The random word array.\r\n     * @static\r\n     * @example\r\n     *   var wordArray = CryptoJS.lib.WordArray.random(16);\r\n     */\r\n    static random(nBytes) {\r\n        const words = [];\r\n        for (let i = 0; i < nBytes; i++) {\r\n            words.push(random());\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nimport { Utf8 } from \"../encoder/Utf8\";\r\nexport class BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        this._minBufferSize = 0;\r\n        this._blockSize = 0;\r\n        this._props = props;\r\n        this._data = props && typeof props.data !== \"undefined\" ? props.data.clone() : new Word32Array();\r\n        this._nBytes = props && typeof props.nBytes === \"number\" ? props.nBytes : 0;\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *   bufferedBlockAlgorithm.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        this._data = typeof data !== \"undefined\" ? data.clone() : new Word32Array();\r\n        this._nBytes = typeof nBytes === \"number\" ? nBytes : 0;\r\n    }\r\n    /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {Word32Array|string} data The data to append. Strings are converted to a WordArray using UTF-8.\r\n     * @example\r\n     *   bufferedBlockAlgorithm.append('data');\r\n     *   bufferedBlockAlgorithm.append(wordArray);\r\n     */\r\n    _append(data) {\r\n        const d = typeof data === \"string\" ? Utf8.parse(data) : data;\r\n        this._data.concat(d);\r\n        this._nBytes += d.nSigBytes;\r\n    }\r\n    /**\r\n     * Processes available data blocks.\r\n     * This method invokes doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean?} doFlush Whether all blocks and partial blocks should be processed.\r\n     * @return {Word32Array} The processed data.\r\n     * @example\r\n     *   var processedData = bufferedBlockAlgorithm.process();\r\n     *   var processedData = bufferedBlockAlgorithm.process(!!'flush');\r\n     */\r\n    _process(doFlush) {\r\n        let processedWords;\r\n        const words = this._data.words;\r\n        const nSigBytes = this._data.nSigBytes;\r\n        const blockSize = this._blockSize;\r\n        const blockSizeByte = this._blockSize * 4;\r\n        let nBlocksReady = nSigBytes / blockSizeByte;\r\n        if (doFlush) {\r\n            // Round up to include partial blocks\r\n            nBlocksReady = Math.ceil(nBlocksReady);\r\n        }\r\n        else {\r\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n        }\r\n        // Count words ready\r\n        const nWordsReady = nBlocksReady * blockSize;\r\n        // Count bytes ready\r\n        const nBytesReady = Math.min(nWordsReady * 4, nSigBytes);\r\n        // Process blocks\r\n        if (nWordsReady) {\r\n            for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n                // Perform concrete-algorithm logic\r\n                this._doProcessBlock(words, offset);\r\n            }\r\n            // Remove processed words\r\n            processedWords = words.splice(0, nWordsReady);\r\n            this._data.nSigBytes -= nBytesReady;\r\n        }\r\n        // Return processed words\r\n        return new Word32Array(processedWords, nBytesReady);\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"./BufferedBlockAlgorithm\";\r\nexport class Hasher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 512 / 32;\r\n        this._props = props;\r\n        if (props && typeof props.blockSize === \"number\") {\r\n            this._blockSize = props.blockSize;\r\n        }\r\n        this.reset(props ? props.data : undefined, props ? props.nBytes : undefined);\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this hasher to its initial state.\r\n     *\r\n     * @example\r\n     *   hasher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        // Reset data buffer\r\n        super.reset.call(this, data, nBytes);\r\n        // Perform concrete-hasher logic\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Updates this hasher with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hasher} This hasher.\r\n     * @example\r\n     *   hasher.update('message');\r\n     *   hasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._append(messageUpdate);\r\n        this._process();\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the hash computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string?} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The hash.\r\n     * @example\r\n     *   var hash = hasher.finalize();\r\n     *   var hash = hasher.finalize('message');\r\n     *   var hash = hasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        // Final message update\r\n        if (messageUpdate) {\r\n            this._append(messageUpdate);\r\n        }\r\n        // Perform concrete-hasher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"../BufferedBlockAlgorithm\";\r\nexport class Cipher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._transformMode = 1;\r\n        this._props = props;\r\n        this._key = props.key;\r\n        this._iv = typeof props.iv !== \"undefined\" ? props.iv : this._iv;\r\n        this._transformMode = typeof props.transformMode !== \"undefined\" ? props.transformMode : this._transformMode;\r\n    }\r\n    get iv() {\r\n        return this._iv;\r\n    }\r\n    /**\r\n     * Resets this cipher to its initial state.\r\n     * @example\r\n     *   cipher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        super.reset(data, nBytes);\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Adds data to be encrypted or decrypted.\r\n     * @param {Word32Array|string} dataUpdate The data to encrypt or decrypt.\r\n     * @return {Word32Array} The data after processing.\r\n     * @example\r\n     *   var encrypted = cipher.process('data');\r\n     *   var encrypted = cipher.process(wordArray);\r\n     */\r\n    process(dataUpdate) {\r\n        this._append(dataUpdate);\r\n        return this._process();\r\n    }\r\n    /**\r\n     * Finalizes the encryption or decryption process.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     * @param {Word32Array|string?} dataUpdate The final data to encrypt or decrypt.\r\n     * @return {Word32Array} The data after final processing.\r\n     * @example\r\n     *   var encrypted = cipher.finalize();\r\n     *   var encrypted = cipher.finalize('data');\r\n     *   var encrypted = cipher.finalize(wordArray);\r\n     */\r\n    finalize(dataUpdate) {\r\n        // Final data update\r\n        if (dataUpdate) {\r\n            this._append(dataUpdate);\r\n        }\r\n        // Perform concrete-cipher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * Creates this cipher in encryption mode.\r\n     *\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createEncryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Cipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.ENC_TRANSFORM_MODE }));\r\n    }\r\n    /**\r\n     * Creates this cipher in decryption mode.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Cipher} A cipher instance.\r\n     * @example\r\n     *   var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\r\n     */\r\n    static createDecryptor(key, props) {\r\n        props = typeof props === \"undefined\" ? {} : props;\r\n        return new Cipher(Object.assign(Object.assign({}, props), { key, transformMode: Cipher.DEC_TRANSFORM_MODE }));\r\n    }\r\n}\r\nCipher.ENC_TRANSFORM_MODE = 1;\r\nCipher.DEC_TRANSFORM_MODE = 2;\r\nCipher.keySize = 128 / 32;\r\nCipher.ivSize = 128 / 32;\r\n","import { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\n/**\r\n * A collection of cipher parameters.\r\n *\r\n * @property {Word32Array} ciphertext The raw ciphertext.\r\n * @property {Word32Array} key The key to this ciphertext.\r\n * @property {Word32Array} iv The IV used in the ciphering operation.\r\n * @property {Word32Array} salt The salt used with a key derivation function.\r\n * @property {typeof Cipher} algorithm The cipher algorithm.\r\n * @property {BlockCipherMode} mode The block mode used in the ciphering operation.\r\n * @property {Pad} padding The padding scheme used in the ciphering operation.\r\n * @property {number} blockSize The block size of the cipher.\r\n * @property {Formatter} formatter The default formatting strategy to convert this cipher params object to a string.\r\n */\r\nexport class CipherParams {\r\n    /**\r\n     * Initializes a newly created cipher params object.\r\n     *\r\n     * @param {Partial<CipherParams>} cp An object with any of the possible cipher parameters.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.lib.CipherParams.create({\r\n     *       ciphertext: ciphertextWordArray,\r\n     *       key: keyWordArray,\r\n     *       iv: ivWordArray,\r\n     *       salt: saltWordArray,\r\n     *       algorithm: JsCrypto.AES,\r\n     *       mode: JsCrypto.CBC,\r\n     *       padding: JsCrypto.PKCS7,\r\n     *       blockSize: 4,\r\n     *       formatter: JsCrypto.OpenSSLFormatter\r\n     *     });\r\n     */\r\n    constructor(cp) {\r\n        this.formatter = OpenSSLFormatter;\r\n        if (cp) {\r\n            this.cipherText = cp.cipherText;\r\n            this.key = cp.key;\r\n            this.iv = cp.iv;\r\n            this.salt = cp.salt;\r\n            this.Algorithm = cp.Algorithm;\r\n            this.mode = cp.mode;\r\n            this.padding = cp.padding;\r\n            this.blockSize = cp.blockSize;\r\n            this.formatter = cp.formatter || OpenSSLFormatter;\r\n        }\r\n    }\r\n    /**\r\n     * Converts this cipher params object to a string.\r\n     *\r\n     * @param {Formatter?} formatter (Optional) The formatting strategy to use.\r\n     * @return {string} The stringified cipher params.\r\n     * @throws Error If neither the formatter nor the default formatter is set.\r\n     * @example\r\n     *   var string = cipherParams + '';\r\n     *   var string = cipherParams.toString();\r\n     *   var string = cipherParams.toString(CryptoJS.format.OpenSSL);\r\n     */\r\n    toString(formatter) {\r\n        return (formatter || this.formatter).stringify(this);\r\n    }\r\n}\r\n","import { parseCipherText, SerializableCipher, } from \"./SerializableCipher\";\r\nimport { OpenSSLKDF } from \"./kdf/OpenSSLKDF\";\r\nimport { CipherParams } from \"./CipherParams\";\r\nimport { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\nexport const PasswordBasedCipher = {\r\n    /**\r\n     * Encrypts a message using a password.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {Word32Array|string} message The message to encrypt.\r\n     * @param {string} password The password.\r\n     * @param {Partial<PasswordBasedCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {CipherParams} A cipher params object.\r\n     * @example\r\n     *   var params = JsCrypto.PasswordBasedCipher.encrypt(JsCrypto.AES, message, 'password');\r\n     *   var params = JsCrypto.PasswordBasedCipher.encrypt(JsCrypto.AES, message, 'password', { format: JsCrypto.OpenSSLFormatter });\r\n     */\r\n    encrypt(Cipher, message, password, props) {\r\n        const p = props ? Object.assign({}, props) : {};\r\n        const KDF = props && props.KDF ? props.KDF : OpenSSLKDF;\r\n        const derivedParams = KDF.execute(password, Cipher.keySize, Cipher.ivSize);\r\n        p.iv = derivedParams.iv;\r\n        const cipherParams = SerializableCipher.encrypt(Cipher, message, derivedParams.key, p);\r\n        return new CipherParams(Object.assign(Object.assign({}, cipherParams), { key: derivedParams.key, iv: derivedParams.iv, salt: derivedParams.salt }));\r\n    },\r\n    /**\r\n     * Decrypts serialized ciphertext using a password.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {CipherParams|string} cipherText The ciphertext to decrypt.\r\n     * @param {string} password The password.\r\n     * @param {Partial<PasswordBasedCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {Word32Array} The plaintext.\r\n     * @example\r\n     *   var plaintext = JsCrypto.PasswordBasedCipher.decrypt(\r\n     *     JsCrypto.AES,\r\n     *     formattedCiphertext,\r\n     *     'password',\r\n     *     { format: JsCrypto.OpenSSLFormatter }\r\n     *   );\r\n     *   var plaintext = JsCrypto.PasswordBasedCipher.decrypt(\r\n     *     JsCrypto.AES,\r\n     *     ciphertextParams,\r\n     *     'password',\r\n     *     { format: JsCrypto.OpenSSLFormatter }\r\n     *   );\r\n     */\r\n    decrypt(Cipher, cipherText, password, props) {\r\n        const p = props ? Object.assign({}, props) : {};\r\n        const KDF = p.KDF ? p.KDF : OpenSSLKDF;\r\n        const formatter = p.formatter ? p.formatter : OpenSSLFormatter;\r\n        const cipherTextParams = parseCipherText(cipherText, formatter);\r\n        const derivedParams = KDF.execute(password, Cipher.keySize, Cipher.ivSize);\r\n        p.iv = derivedParams.iv;\r\n        return SerializableCipher.decrypt(Cipher, cipherTextParams, derivedParams.key, props);\r\n    }\r\n};\r\n","import { OpenSSLFormatter } from \"./formatter/OpenSSLFormatter\";\r\nimport { CipherParams } from \"./CipherParams\";\r\n/**\r\n * Converts serialized ciphertext to CipherParams,\r\n * else assumed CipherParams already and returns ciphertext unchanged.\r\n * @param {CipherParams|string} cipherTextParams The ciphertext.\r\n * @param {Formatter} formatter The formatting strategy to use to parse serialized ciphertext.\r\n * @return {CipherParams} The un-serialized ciphertext.\r\n * @example\r\n *   var ciphertextParams = JsCrypto.SerializableCipher.parse(ciphertextStringOrParams, format);\r\n */\r\nexport function parseCipherText(cipherTextParams, formatter) {\r\n    if (typeof cipherTextParams === \"string\") {\r\n        return formatter.parse(cipherTextParams);\r\n    }\r\n    return cipherTextParams;\r\n}\r\nexport const SerializableCipher = {\r\n    /**\r\n     * Encrypts a message.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {Word32Array|string} message The message to encrypt.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<SerializableCipherProps>?} props (Optional) The configuration options to use for this operation.\r\n     * @return {CipherParams} A cipher params object.\r\n     * @example\r\n     *   var ciphertextParams = JsCrypto.SerializableCipher.encrypt(JsCrypto.AES, message, key);\r\n     *   var ciphertextParams = JsCrypto.SerializableCipher.encrypt(JsCrypto.AES, message, key, { iv: iv });\r\n     */\r\n    encrypt(Cipher, message, key, props) {\r\n        const encryptor = Cipher.createEncryptor(key, props);\r\n        const cipherText = encryptor.finalize(message);\r\n        return new CipherParams({\r\n            cipherText,\r\n            key,\r\n            iv: encryptor.iv,\r\n            Algorithm: Cipher,\r\n            mode: encryptor.mode,\r\n            padding: encryptor.padding,\r\n            blockSize: encryptor.blockSize,\r\n            formatter: (props === null || props === void 0 ? void 0 : props.formatter) || OpenSSLFormatter,\r\n        });\r\n    },\r\n    /**\r\n     * Decrypts serialized ciphertext.\r\n     *\r\n     * @param {typeof Cipher} Cipher The cipher algorithm to use.\r\n     * @param {CipherParams|string} cipherText The ciphertext to decrypt.\r\n     * @param {Word32Array} key The key.\r\n     * @param {Partial<SerializableCipherProps>} props (Optional) The configuration options to use for this operation.\r\n     * @return {Word32Array} The plaintext.\r\n     * @example\r\n     *     var plaintext = JsCrypto.SerializableCipher.decrypt(JsCrypto.AES, formattedCiphertext, key, { iv: iv, format: JsCrypto.OpenSSL });\r\n     *     var plaintext = JsCrypto.SerializableCipher.decrypt(JsCrypto.AES, ciphertextParams, key, { iv: iv, format: JsCrypto.OpenSSL });\r\n     */\r\n    decrypt(Cipher, cipherText, key, props) {\r\n        const decryptor = Cipher.createDecryptor(key, props);\r\n        const cipherParams = parseCipherText(cipherText, (props === null || props === void 0 ? void 0 : props.formatter) || OpenSSLFormatter);\r\n        return decryptor.finalize(cipherParams.cipherText || \"\");\r\n    }\r\n};\r\n","import { Cipher } from \"./Cipher\";\r\nexport class StreamCipher extends Cipher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 1;\r\n    }\r\n    _doFinalize() {\r\n        return this._process(true);\r\n    }\r\n}\r\n","import { CipherParams } from \"../CipherParams\";\r\nimport { Word32Array } from \"../../../Word32Array\";\r\nimport { Base64 } from \"../../../encoder/Base64\";\r\nexport const OpenSSLFormatter = {\r\n    /**\r\n     * Converts a cipher params object to an OpenSSL-compatible string.\r\n     *\r\n     * @param {CipherParams} cipherParams The cipher params object.\r\n     * @return {string} The OpenSSL-compatible string.\r\n     * @example\r\n     *   var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\r\n     */\r\n    stringify(cipherParams) {\r\n        // Shortcuts\r\n        const cipherText = cipherParams.cipherText;\r\n        const salt = cipherParams.salt;\r\n        if (!cipherText) {\r\n            return \"\";\r\n        }\r\n        // Format\r\n        if (salt) {\r\n            const wordArray = new Word32Array([0x53616c74, 0x65645f5f]).concat(salt).concat(cipherText);\r\n            return wordArray.toString(Base64);\r\n        }\r\n        return cipherText.toString(Base64);\r\n    },\r\n    /**\r\n     * Converts an OpenSSL-compatible string to a cipher params object.\r\n     *\r\n     * @param {string} openSSLStr The OpenSSL-compatible string.\r\n     * @return {CipherParams} The cipher params object.\r\n     * @example\r\n     *   var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\r\n     */\r\n    parse(openSSLStr) {\r\n        let salt;\r\n        // Parse base64\r\n        const cipherText = Base64.parse(openSSLStr);\r\n        // Shortcut\r\n        const ciphertextWords = cipherText.words;\r\n        // Test for salt\r\n        if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\r\n            // Extract salt\r\n            salt = new Word32Array(ciphertextWords.slice(2, 4));\r\n            // Remove salt from ciphertext\r\n            ciphertextWords.splice(0, 4);\r\n            cipherText.nSigBytes -= 16;\r\n        }\r\n        return new CipherParams({ cipherText, salt });\r\n    }\r\n};\r\n","import { Word32Array } from \"../../../Word32Array\";\r\nimport { CipherParams } from \"../CipherParams\";\r\nimport { EvpKDF } from \"./module/EvpKDF\";\r\n/**\r\n * Derives a key and IV from a password.\r\n *\r\n * @param {string} password The password to derive from.\r\n * @param {number} keySize The size in words of the key to generate.\r\n * @param {number} ivSize The size in words of the IV to generate.\r\n * @param {Word32Array?} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\r\n * @return {CipherParams} A cipher params object with the key, IV, and salt.\r\n * @example\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32);\r\n *   var derivedParams = JsCrypto.OpenSSLKDF.execute('Password', 256/32, 128/32, 'saltsalt');\r\n */\r\nexport const OpenSSLKDF = {\r\n    execute(password, keySize, ivSize, salt, props) {\r\n        // Generate random salt\r\n        if (!salt) {\r\n            salt = Word32Array.random(64 / 8);\r\n        }\r\n        const KDFModule = props && props.KDF || EvpKDF;\r\n        const kdfProps = props ? { Hasher: props.Hasher, iterations: props.iterations } : {};\r\n        // Derive key and IV\r\n        const key = KDFModule.getKey(password, salt, Object.assign(Object.assign({}, kdfProps), { keySize: keySize + ivSize }));\r\n        // Separate key and IV\r\n        const iv = new Word32Array(key.words.slice(keySize), ivSize * 4);\r\n        key.nSigBytes = keySize * 4;\r\n        // Return params\r\n        return new CipherParams({ key, iv, salt });\r\n    }\r\n};\r\n","import { MD5 } from \"../../../../../MD5\";\r\nimport { Word32Array } from \"../../../../Word32Array\";\r\nimport { BaseKDFModule } from \"../type\";\r\n/**\r\n * This key derivation function is meant to conform with EVP_BytesToKey.\r\n * https://www.openssl.org/docs/man1.1.1/man3/EVP_BytesToKey.html\r\n *\r\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n * @property {Hasher} hasher The hash algorithm to use. Default: MD5\r\n * @property {number} iterations The number of iterations to perform. Default: 1\r\n */\r\nexport class EvpKDF extends BaseKDFModule {\r\n    constructor(props) {\r\n        super(props);\r\n        this._keySize = 128 / 32;\r\n        this._Hasher = MD5;\r\n        this._iterations = 1;\r\n        if (props) {\r\n            this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\r\n            this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\r\n            this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\r\n        }\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @return {Word32Array} The derived key.\r\n     * @example\r\n     *   var key = kdf.compute(password, salt);\r\n     */\r\n    compute(password, salt) {\r\n        let block;\r\n        // Init hasher\r\n        const hasher = new this._Hasher();\r\n        // Initial values\r\n        const derivedKey = new Word32Array();\r\n        // Shortcuts\r\n        const derivedKeyWords = derivedKey.words;\r\n        const keySize = this._keySize;\r\n        const iterations = this._iterations;\r\n        // Generate key\r\n        while (derivedKeyWords.length < keySize) {\r\n            if (block) {\r\n                hasher.update(block);\r\n            }\r\n            block = hasher.update(password).finalize(salt);\r\n            hasher.reset();\r\n            // Iterations\r\n            for (let i = 1; i < iterations; i++) {\r\n                block = hasher.finalize(block);\r\n                hasher.reset();\r\n            }\r\n            derivedKey.concat(block);\r\n        }\r\n        derivedKey.nSigBytes = keySize * 4;\r\n        return derivedKey;\r\n    }\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param {Word32Array|string} password The password.\r\n     * @param {Word32Array|string} salt A salt.\r\n     * @param {Partial<EvpKDFProps>?} props (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {Word32Array} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = EvpKDF.getKey(password, salt);\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8 });\r\n     *     var key = EvpKDF.getKey(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\r\n    static getKey(password, salt, props) {\r\n        return new EvpKDF(props).compute(password, salt);\r\n    }\r\n}\r\n","export class BaseKDFModule {\r\n    constructor(props) {\r\n        this._props = props;\r\n    }\r\n    compute(password, salt) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    static getKey(password, salt, props) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nconst map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst reverseMap = [];\r\nfor (let i = 0; i < map.length; i++) {\r\n    reverseMap[map.charCodeAt(i)] = i;\r\n}\r\nexport const Base64 = {\r\n    /**\r\n     * Converts a word array to a base64 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The base64 string.\r\n     * @example\r\n     *   var hexString = Base64.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        // Shortcuts\r\n        const words = w.words;\r\n        const sigBytes = w.nSigBytes;\r\n        // Clamp excess bits\r\n        w.clamp();\r\n        // Convert\r\n        const base64Chars = [];\r\n        for (let i = 0; i < sigBytes; i += 3) {\r\n            const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\r\n            const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\r\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\r\n            for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\r\n                base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\r\n            }\r\n        }\r\n        // Add padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            while (base64Chars.length % 4) {\r\n                base64Chars.push(paddingChar);\r\n            }\r\n        }\r\n        return base64Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a base64 string to a word array.\r\n     *\r\n     * @param {string} base64Str The base64 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Base64.parse(base64String);\r\n     */\r\n    parse(base64Str) {\r\n        let base64StrLength = base64Str.length;\r\n        // Ignore padding\r\n        const paddingChar = map.charAt(64);\r\n        if (paddingChar) {\r\n            const paddingIndex = base64Str.indexOf(paddingChar);\r\n            if (paddingIndex !== -1) {\r\n                base64StrLength = paddingIndex;\r\n            }\r\n        }\r\n        const words = [];\r\n        let nBytes = 0;\r\n        for (let i = 0; i < base64StrLength; i++) {\r\n            if (i % 4) {\r\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\r\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\r\n                const bitsCombined = bits1 | bits2;\r\n                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\r\n                nBytes++;\r\n            }\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Hex = {\r\n    /**\r\n     * Converts a word array to a hex string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The hex string.\r\n     * @example\r\n     *   var hexString = Hex.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const hexChars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            hexChars.push((byte >>> 4).toString(16));\r\n            hexChars.push((byte & 0x0f).toString(16));\r\n        }\r\n        return hexChars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a hex string to a word array.\r\n     *\r\n     * @param {string} hexStr The hex string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Hex.parse(hexString);\r\n     */\r\n    parse(hexStr) {\r\n        const Len = hexStr.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i += 2) {\r\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\r\n        }\r\n        return new Word32Array(words, Len / 2);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Latin1 = {\r\n    /**\r\n     * Converts a word array to a Latin1 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The Latin1 string.\r\n     * @example\r\n     *   var latin1String = Latin1.stringify([0x293892], 6);\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const latin1Chars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            latin1Chars.push(String.fromCharCode(byte));\r\n        }\r\n        return latin1Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a latin1 string to a word array.\r\n     *\r\n     * @param {string} latin1Str The latin1 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Latin1.parse(latin1Str);\r\n     */\r\n    parse(latin1Str) {\r\n        const Len = latin1Str.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i++) {\r\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\r\n        }\r\n        return new Word32Array(words, Len);\r\n    }\r\n};\r\n","import { Latin1 } from \"./Latin1\";\r\nexport const Utf8 = {\r\n    /**\r\n     * Converts a word array to a UTF-8 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-8 string.\r\n     * @example\r\n     *   var utf8String = Utf8.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        try {\r\n            return decodeURIComponent(escape(Latin1.stringify(w)));\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Malformed UTF-8 data\");\r\n        }\r\n    },\r\n    /**\r\n     * Converts a UTF-8 string to a word array.\r\n     *\r\n     * @param {string} utf8Str The UTF-8 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Utf8.parse(utf8Str);\r\n     */\r\n    parse(utf8Str) {\r\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\r\n    }\r\n};\r\n","function makeRandFunction() {\r\n    if (typeof window !== \"undefined\") {\r\n        const c = window.crypto || window.msCrypto;\r\n        if (!c) {\r\n            throw new Error(\"Crypto module not found\");\r\n        }\r\n        return function rand() {\r\n            return c.getRandomValues(new Uint32Array(1))[0];\r\n        };\r\n    }\r\n    else if (typeof global !== \"undefined\" && global.crypto) {\r\n        return function rand() {\r\n            return global.crypto.randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    else if (typeof require === \"function\") {\r\n        return function rand() {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore\r\n            return __non_webpack_require__(\"crypto\").randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    throw new Error(\"Unable to find crypto module\");\r\n}\r\nexport const random = makeRandFunction();\r\n"],"sourceRoot":""}