{"version":3,"sources":["webpack://JsCrypto/webpack/universalModuleDefinition","webpack://JsCrypto/webpack/bootstrap","webpack://JsCrypto/(webpack)/buildin/global.js","webpack://JsCrypto/./src/SHA384.ts","webpack://JsCrypto/./src/SHA512.ts","webpack://JsCrypto/./src/lib/Word32Array.ts","webpack://JsCrypto/./src/lib/Word64Array.ts","webpack://JsCrypto/./src/lib/algorithm/BufferedBlockAlgorithm.ts","webpack://JsCrypto/./src/lib/algorithm/Hasher.ts","webpack://JsCrypto/./src/lib/encoder/Hex.ts","webpack://JsCrypto/./src/lib/encoder/Latin1.ts","webpack://JsCrypto/./src/lib/encoder/Utf8.ts","webpack://JsCrypto/./src/lib/random.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAwD;AACtB;AAC3B,qBAAqB,8CAAM;AAClC;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAgD;AACQ;AACxD;AACA,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD,QAAQ,uDAAM,8BAA8B,uDAAM;AAClD;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,uDAAM;AACzB;AACA,CAAC;AACM,qBAAqB,4DAAM;AAClC;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAW;AACpC,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D,gBAAgB,uDAAM,8BAA8B,uDAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAoC;AACF;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,uBAAuB,sDAAM;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACQ;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAA6C;AACN;AAChC;AACP;AACA;AACA;AACA;AACA,2FAA2F,wDAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wDAAW;AACjF;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAkE;AAC3D,qBAAqB,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAkC;AAC3B;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAM;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAA6B;AAC1C;AACA;AACA;AACA,mBAAmB,OAAuB;AAC1C;AACA;AACA;AACA;AACO","file":"SHA384.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsCrypto\"] = factory();\n\telse\n\t\troot[\"JsCrypto\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/SHA384.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Word64, Word64Array } from \"./lib/Word64Array\";\r\nimport { SHA512 } from \"./SHA512\";\r\nexport class SHA384 extends SHA512 {\r\n    constructor(props) {\r\n        super(props);\r\n        this._hash = new Word64Array([\r\n            new Word64(0xcbbb9d5d, 0xc1059ed8), new Word64(0x629a292a, 0x367cd507),\r\n            new Word64(0x9159015a, 0x3070dd17), new Word64(0x152fecd8, 0xf70e5939),\r\n            new Word64(0x67332667, 0xffc00b31), new Word64(0x8eb44a87, 0x68581511),\r\n            new Word64(0xdb0c2e0d, 0x64f98fa7), new Word64(0x47b5481d, 0xbefa4fa4)\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word64Array([\r\n            new Word64(0xcbbb9d5d, 0xc1059ed8), new Word64(0x629a292a, 0x367cd507),\r\n            new Word64(0x9159015a, 0x3070dd17), new Word64(0x152fecd8, 0xf70e5939),\r\n            new Word64(0x67332667, 0xffc00b31), new Word64(0x8eb44a87, 0x68581511),\r\n            new Word64(0xdb0c2e0d, 0x64f98fa7), new Word64(0x47b5481d, 0xbefa4fa4)\r\n        ]);\r\n    }\r\n    _doFinalize() {\r\n        const hash = super._doFinalize.call(this);\r\n        hash.nSigBytes -= 16;\r\n        return hash;\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA384(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA384(props).finalize(message);\r\n    }\r\n}\r\n","import { Hasher } from \"./lib/algorithm/Hasher\";\r\nimport { Word64, Word64Array } from \"./lib/Word64Array\";\r\nconst K = [\r\n    new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd),\r\n    new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc),\r\n    new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019),\r\n    new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118),\r\n    new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe),\r\n    new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2),\r\n    new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1),\r\n    new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694),\r\n    new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3),\r\n    new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65),\r\n    new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483),\r\n    new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5),\r\n    new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210),\r\n    new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4),\r\n    new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725),\r\n    new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70),\r\n    new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926),\r\n    new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df),\r\n    new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8),\r\n    new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b),\r\n    new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001),\r\n    new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30),\r\n    new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910),\r\n    new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8),\r\n    new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53),\r\n    new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8),\r\n    new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb),\r\n    new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3),\r\n    new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60),\r\n    new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec),\r\n    new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9),\r\n    new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b),\r\n    new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207),\r\n    new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178),\r\n    new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6),\r\n    new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b),\r\n    new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493),\r\n    new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c),\r\n    new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a),\r\n    new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817),\r\n];\r\nconst W = [];\r\n(function computeConstants() {\r\n    for (let i = 0; i < 80; i++) {\r\n        W[i] = new Word64(0, 0);\r\n    }\r\n})();\r\nexport class SHA512 extends Hasher {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 1024 / 32;\r\n        this._hash = new Word64Array([\r\n            new Word64(0x6a09e667, 0xf3bcc908), new Word64(0xbb67ae85, 0x84caa73b),\r\n            new Word64(0x3c6ef372, 0xfe94f82b), new Word64(0xa54ff53a, 0x5f1d36f1),\r\n            new Word64(0x510e527f, 0xade682d1), new Word64(0x9b05688c, 0x2b3e6c1f),\r\n            new Word64(0x1f83d9ab, 0xfb41bd6b), new Word64(0x5be0cd19, 0x137e2179)\r\n        ]);\r\n        this._props = props;\r\n        if (props && typeof props.hash !== \"undefined\") {\r\n            this._hash = props.hash.clone();\r\n        }\r\n    }\r\n    _doReset() {\r\n        this._hash = new Word64Array([\r\n            new Word64(0x6a09e667, 0xf3bcc908), new Word64(0xbb67ae85, 0x84caa73b),\r\n            new Word64(0x3c6ef372, 0xfe94f82b), new Word64(0xa54ff53a, 0x5f1d36f1),\r\n            new Word64(0x510e527f, 0xade682d1), new Word64(0x9b05688c, 0x2b3e6c1f),\r\n            new Word64(0x1f83d9ab, 0xfb41bd6b), new Word64(0x5be0cd19, 0x137e2179)\r\n        ]);\r\n    }\r\n    _doProcessBlock(words, offset) {\r\n        // Shortcuts\r\n        const H = this._hash.words;\r\n        const H0 = H[0];\r\n        const H1 = H[1];\r\n        const H2 = H[2];\r\n        const H3 = H[3];\r\n        const H4 = H[4];\r\n        const H5 = H[5];\r\n        const H6 = H[6];\r\n        const H7 = H[7];\r\n        const H0h = H0.high;\r\n        let H0l = H0.low;\r\n        const H1h = H1.high;\r\n        let H1l = H1.low;\r\n        const H2h = H2.high;\r\n        let H2l = H2.low;\r\n        const H3h = H3.high;\r\n        let H3l = H3.low;\r\n        const H4h = H4.high;\r\n        let H4l = H4.low;\r\n        const H5h = H5.high;\r\n        let H5l = H5.low;\r\n        const H6h = H6.high;\r\n        let H6l = H6.low;\r\n        const H7h = H7.high;\r\n        let H7l = H7.low;\r\n        // Working variables\r\n        let ah = H0h;\r\n        let al = H0l;\r\n        let bh = H1h;\r\n        let bl = H1l;\r\n        let ch = H2h;\r\n        let cl = H2l;\r\n        let dh = H3h;\r\n        let dl = H3l;\r\n        let eh = H4h;\r\n        let el = H4l;\r\n        let fh = H5h;\r\n        let fl = H5l;\r\n        let gh = H6h;\r\n        let gl = H6l;\r\n        let hh = H7h;\r\n        let hl = H7l;\r\n        // Rounds\r\n        for (let i = 0; i < 80; i++) {\r\n            let Wil;\r\n            let Wih;\r\n            // Shortcut\r\n            const Wi = W[i];\r\n            // Extend message\r\n            if (i < 16) {\r\n                Wih = Wi.high = words[offset + i * 2] | 0;\r\n                Wil = Wi.low = words[offset + i * 2 + 1] | 0;\r\n            }\r\n            else {\r\n                // Gamma0\r\n                const gamma0x = W[i - 15];\r\n                const gamma0xh = gamma0x.high;\r\n                const gamma0xl = gamma0x.low;\r\n                const gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31))\r\n                    ^ ((gamma0xh >>> 8) | (gamma0xl << 24))\r\n                    ^ (gamma0xh >>> 7);\r\n                const gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31))\r\n                    ^ ((gamma0xl >>> 8) | (gamma0xh << 24))\r\n                    ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\r\n                // Gamma1\r\n                const gamma1x = W[i - 2];\r\n                const gamma1xh = gamma1x.high;\r\n                const gamma1xl = gamma1x.low;\r\n                const gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13))\r\n                    ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\r\n                const gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13))\r\n                    ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\r\n                // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\r\n                const Wi7 = W[i - 7];\r\n                const Wi7h = Wi7.high;\r\n                const Wi7l = Wi7.low;\r\n                const Wi16 = W[i - 16];\r\n                const Wi16h = Wi16.high;\r\n                const Wi16l = Wi16.low;\r\n                Wil = gamma0l + Wi7l;\r\n                Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\r\n                Wil = Wil + gamma1l;\r\n                Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\r\n                Wil = Wil + Wi16l;\r\n                Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\r\n                Wi.high = Wih;\r\n                Wi.low = Wil;\r\n            }\r\n            const chh = (eh & fh) ^ (~eh & gh);\r\n            const chl = (el & fl) ^ (~el & gl);\r\n            const majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\r\n            const majl = (al & bl) ^ (al & cl) ^ (bl & cl);\r\n            const sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\r\n            const sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\r\n            const sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\r\n            const sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\r\n            // t1 = h + sigma1 + ch + K[i] + W[i]\r\n            const Ki = K[i];\r\n            const Kih = Ki.high;\r\n            const Kil = Ki.low;\r\n            let t1l = hl + sigma1l;\r\n            let t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\r\n            t1l = t1l + chl;\r\n            t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\r\n            t1l = t1l + Kil;\r\n            t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\r\n            t1l = t1l + Wil;\r\n            t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\r\n            // t2 = sigma0 + maj\r\n            const t2l = sigma0l + majl;\r\n            const t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\r\n            // Update working variables\r\n            hh = gh;\r\n            hl = gl;\r\n            gh = fh;\r\n            gl = fl;\r\n            fh = eh;\r\n            fl = el;\r\n            el = (dl + t1l) | 0;\r\n            eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\r\n            dh = ch;\r\n            dl = cl;\r\n            ch = bh;\r\n            cl = bl;\r\n            bh = ah;\r\n            bl = al;\r\n            al = (t1l + t2l) | 0;\r\n            ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\r\n        }\r\n        // Intermediate hash value\r\n        H0l = H0.low = (H0l + al);\r\n        H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\r\n        H1l = H1.low = (H1l + bl);\r\n        H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\r\n        H2l = H2.low = (H2l + cl);\r\n        H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\r\n        H3l = H3.low = (H3l + dl);\r\n        H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\r\n        H4l = H4.low = (H4l + el);\r\n        H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\r\n        H5l = H5.low = (H5l + fl);\r\n        H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\r\n        H6l = H6.low = (H6l + gl);\r\n        H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\r\n        H7l = H7.low = (H7l + hl);\r\n        H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\r\n    }\r\n    _doFinalize() {\r\n        // Shortcuts\r\n        const data = this._data;\r\n        const dataWords = data.words;\r\n        const nBitsTotal = this._nBytes * 8;\r\n        const nBitsLeft = data.nSigBytes * 8;\r\n        // Add padding\r\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\r\n        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\r\n        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\r\n        data.nSigBytes = dataWords.length * 4;\r\n        // Hash final blocks\r\n        this._process();\r\n        // Convert hash to 32-bit word array before returning\r\n        return this._hash.to32();\r\n    }\r\n    clone() {\r\n        const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };\r\n        return new SHA512(props);\r\n    }\r\n    static hash(message, props) {\r\n        return new SHA512(props).finalize(message);\r\n    }\r\n}\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { random } from \"./random\";\r\n/**\r\n * An array of 32bit words\r\n */\r\nexport class Word32Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 4;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this);\r\n        }\r\n        return encoder.stringify(this);\r\n    }\r\n    /**\r\n     * Concatenates a word array to this word array.\r\n     *\r\n     * @param {Word32Array} w The word array to append.\r\n     * @return {Word32Array} This word array.\r\n     * @example\r\n     *   wordArray1.concat(wordArray2);\r\n     */\r\n    concat(w) {\r\n        const words = w.words.slice();\r\n        const N = w.nSigBytes;\r\n        this.clamp();\r\n        if (this._nSignificantBytes % 4) {\r\n            // Copy one byte at a time\r\n            for (let i = 0; i < N; i++) {\r\n                const b = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n                this._words[(this._nSignificantBytes + i) >>> 2] |= b << (24 - ((this._nSignificantBytes + i) % 4) * 8);\r\n            }\r\n        }\r\n        else {\r\n            // Copy one word at a time\r\n            for (let i = 0; i < N; i += 4) {\r\n                this._words[(this._nSignificantBytes + i) >>> 2] = words[i >>> 2];\r\n            }\r\n        }\r\n        this._nSignificantBytes += N;\r\n        // Chainable\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes insignificant bits.\r\n     *\r\n     * @example\r\n     *   wordArray.clamp();\r\n     */\r\n    clamp() {\r\n        const n = this._nSignificantBytes;\r\n        this._words[n >>> 2] &= 0xffffffff << (32 - (n % 4) * 8);\r\n        this._words.length = Math.ceil(n / 4);\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word32Array} The clone.\r\n     * @example\r\n     *   var clone = word32Array.clone();\r\n     */\r\n    clone() {\r\n        return new Word32Array(this._words.slice(), this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Creates a word array filled with random bytes.\r\n     *\r\n     * @param {number} nBytes The number of random bytes to generate.\r\n     * @return {Word32Array} The random word array.\r\n     * @static\r\n     * @example\r\n     *   var wordArray = Word32Array.random(16);\r\n     */\r\n    static random(nBytes) {\r\n        const words = [];\r\n        for (let i = 0; i < nBytes; i++) {\r\n            words.push(random());\r\n        }\r\n        return new Word32Array(words, nBytes);\r\n    }\r\n}\r\n","import { Hex } from \"./encoder/Hex\";\r\nimport { Word32Array } from \"./Word32Array\";\r\nexport class Word64 {\r\n    constructor(high, low) {\r\n        this.high = high;\r\n        this.low = low;\r\n    }\r\n    clone() {\r\n        return new Word64(this.high, this.low);\r\n    }\r\n}\r\n/**\r\n * An array of 64bit words\r\n */\r\nexport class Word64Array {\r\n    /**\r\n     * Initializes a newly created word array.\r\n     *\r\n     * @param {Array} words (Optional) An array of 32-bit words.\r\n     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.\r\n     *\r\n     * @example\r\n     *   var wordArray = new WordArray();\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607]);\r\n     *   var wordArray = new WordArray([0x00010203, 0x04050607], 6);\r\n     */\r\n    constructor(words, nSignificantBytes) {\r\n        this._words = words || [];\r\n        this._nSignificantBytes = typeof nSignificantBytes === \"number\" ? nSignificantBytes : this._words.length * 8;\r\n    }\r\n    get nSigBytes() {\r\n        return this._nSignificantBytes;\r\n    }\r\n    /**\r\n     * Set significant bytes\r\n     * @param {number} n - significant bytes\r\n     */\r\n    set nSigBytes(n) {\r\n        this._nSignificantBytes = n;\r\n    }\r\n    /**\r\n     * Get raw reference of internal words.\r\n     * Modification of this raw array will affect internal words.\r\n     */\r\n    get words() {\r\n        return this._words;\r\n    }\r\n    /**\r\n     * Converts this 64-bit word array to a 32-bit word array.\r\n     *\r\n     * @return {Word32Array} This word array's data as a 32-bit word array.\r\n     *\r\n     * @example\r\n     *\r\n     *     var x32WordArray = x64WordArray.toX32();\r\n     */\r\n    to32() {\r\n        const words32 = [];\r\n        for (let i = 0; i < this._words.length; i++) {\r\n            const word64 = this._words[i];\r\n            words32.push(word64.high);\r\n            words32.push(word64.low);\r\n        }\r\n        return new Word32Array(words32, this._nSignificantBytes);\r\n    }\r\n    /**\r\n     * Converts this word array to a string.\r\n     *\r\n     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n     * @return {string} The stringified word array.\r\n     * @example\r\n     *   var string = wordArray + '';\r\n     *   var string = wordArray.toString();\r\n     *   var string = wordArray.toString(Utf8);\r\n     */\r\n    toString(encoder) {\r\n        if (!encoder) {\r\n            return Hex.stringify(this.to32());\r\n        }\r\n        return encoder.stringify(this.to32());\r\n    }\r\n    /**\r\n     * Creates a copy of this word array.\r\n     *\r\n     * @return {Word64Array} The clone.\r\n     * @example\r\n     *   var clone = wordArray.clone();\r\n     */\r\n    clone() {\r\n        const words = this._words.slice();\r\n        for (let i = 0; i < words.length; i++) {\r\n            words[i] = words[i].clone();\r\n        }\r\n        return new Word64Array(words, this._nSignificantBytes);\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nimport { Utf8 } from \"../encoder/Utf8\";\r\nexport class BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        this._minBufferSize = 0;\r\n        this._blockSize = 0;\r\n        this._props = props;\r\n        this._data = props && typeof props.data !== \"undefined\" ? props.data.clone() : new Word32Array();\r\n        this._nBytes = props && typeof props.nBytes === \"number\" ? props.nBytes : 0;\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *   bufferedBlockAlgorithm.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        this._data = typeof data !== \"undefined\" ? data.clone() : new Word32Array();\r\n        this._nBytes = typeof nBytes === \"number\" ? nBytes : 0;\r\n    }\r\n    /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {Word32Array|string} data The data to append. Strings are converted to a WordArray using UTF-8.\r\n     * @example\r\n     *   bufferedBlockAlgorithm.append('data');\r\n     *   bufferedBlockAlgorithm.append(wordArray);\r\n     */\r\n    _append(data) {\r\n        const d = typeof data === \"string\" ? Utf8.parse(data) : data;\r\n        this._data.concat(d);\r\n        this._nBytes += d.nSigBytes;\r\n    }\r\n    /**\r\n     * Processes available data blocks.\r\n     * This method invokes doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean?} doFlush Whether all blocks and partial blocks should be processed.\r\n     * @return {Word32Array} The processed data.\r\n     * @example\r\n     *   var processedData = bufferedBlockAlgorithm.process();\r\n     *   var processedData = bufferedBlockAlgorithm.process(!!'flush');\r\n     */\r\n    _process(doFlush) {\r\n        let processedWords;\r\n        const words = this._data.words;\r\n        const nSigBytes = this._data.nSigBytes;\r\n        const blockSize = this._blockSize;\r\n        const blockSizeByte = this._blockSize * 4;\r\n        let nBlocksReady = nSigBytes / blockSizeByte;\r\n        if (doFlush) {\r\n            // Round up to include partial blocks\r\n            nBlocksReady = Math.ceil(nBlocksReady);\r\n        }\r\n        else {\r\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n        }\r\n        // Count words ready\r\n        const nWordsReady = nBlocksReady * blockSize;\r\n        // Count bytes ready\r\n        const nBytesReady = Math.min(nWordsReady * 4, nSigBytes);\r\n        // Process blocks\r\n        if (nWordsReady) {\r\n            for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n                // Perform concrete-algorithm logic\r\n                this._doProcessBlock(words, offset);\r\n            }\r\n            // Remove processed words\r\n            processedWords = words.splice(0, nWordsReady);\r\n            this._data.nSigBytes -= nBytesReady;\r\n        }\r\n        // Return processed words\r\n        return new Word32Array(processedWords, nBytesReady);\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doProcessBlock(words, offset) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { BufferedBlockAlgorithm } from \"./BufferedBlockAlgorithm\";\r\nexport class Hasher extends BufferedBlockAlgorithm {\r\n    constructor(props) {\r\n        super(props);\r\n        this._blockSize = 512 / 32;\r\n        this._props = props;\r\n        if (props && typeof props.blockSize === \"number\") {\r\n            this._blockSize = props.blockSize;\r\n        }\r\n        this.reset(props ? props.data : undefined, props ? props.nBytes : undefined);\r\n    }\r\n    get blockSize() {\r\n        return this._blockSize;\r\n    }\r\n    /**\r\n     * Resets this hasher to its initial state.\r\n     *\r\n     * @example\r\n     *   hasher.reset();\r\n     */\r\n    reset(data, nBytes) {\r\n        // Reset data buffer\r\n        super.reset.call(this, data, nBytes);\r\n        // Perform concrete-hasher logic\r\n        this._doReset();\r\n    }\r\n    /**\r\n     * Updates this hasher with a message.\r\n     *\r\n     * @param {Word32Array|string} messageUpdate The message to append.\r\n     * @return {Hasher} This hasher.\r\n     * @example\r\n     *   hasher.update('message');\r\n     *   hasher.update(wordArray);\r\n     */\r\n    update(messageUpdate) {\r\n        this._append(messageUpdate);\r\n        this._process();\r\n        return this;\r\n    }\r\n    /**\r\n     * Finalizes the hash computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {Word32Array|string?} messageUpdate (Optional) A final message update.\r\n     * @return {Word32Array} The hash.\r\n     * @example\r\n     *   var hash = hasher.finalize();\r\n     *   var hash = hasher.finalize('message');\r\n     *   var hash = hasher.finalize(wordArray);\r\n     */\r\n    finalize(messageUpdate) {\r\n        // Final message update\r\n        if (messageUpdate) {\r\n            this._append(messageUpdate);\r\n        }\r\n        // Perform concrete-hasher logic\r\n        return this._doFinalize();\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doReset() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    _doFinalize() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Hex = {\r\n    /**\r\n     * Converts a word array to a hex string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The hex string.\r\n     * @example\r\n     *   var hexString = Hex.stringify(new Word32Array([0x293892], 6));\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const hexChars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            hexChars.push((byte >>> 4).toString(16));\r\n            hexChars.push((byte & 0x0f).toString(16));\r\n        }\r\n        return hexChars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a hex string to a word array.\r\n     *\r\n     * @param {string} hexStr The hex string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Hex.parse(hexString);\r\n     */\r\n    parse(hexStr) {\r\n        const Len = hexStr.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i += 2) {\r\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\r\n        }\r\n        return new Word32Array(words, Len / 2);\r\n    }\r\n};\r\n","import { Word32Array } from \"../Word32Array\";\r\nexport const Latin1 = {\r\n    /**\r\n     * Converts a word array to a Latin1 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The Latin1 string.\r\n     * @example\r\n     *   var latin1String = Latin1.stringify(new Word32Array([0x293892], 6));\r\n     */\r\n    stringify(w) {\r\n        const nSig = w.nSigBytes;\r\n        const words = w.words;\r\n        const latin1Chars = [];\r\n        for (let i = 0; i < nSig; i++) {\r\n            const byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n            latin1Chars.push(String.fromCharCode(byte));\r\n        }\r\n        return latin1Chars.join(\"\");\r\n    },\r\n    /**\r\n     * Converts a latin1 string to a word array.\r\n     *\r\n     * @param {string} latin1Str The latin1 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Latin1.parse(latin1Str);\r\n     */\r\n    parse(latin1Str) {\r\n        const Len = latin1Str.length;\r\n        const words = [];\r\n        for (let i = 0; i < Len; i++) {\r\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\r\n        }\r\n        return new Word32Array(words, Len);\r\n    }\r\n};\r\n","import { Latin1 } from \"./Latin1\";\r\nexport const Utf8 = {\r\n    /**\r\n     * Converts a word array to a UTF-8 string.\r\n     *\r\n     * @param {Word32Array} w An array of 32-bit words.\r\n     * @return {string} The UTF-8 string.\r\n     * @example\r\n     *   var utf8String = Utf8.stringify(new Word32Array([0x293892]));\r\n     */\r\n    stringify(w) {\r\n        try {\r\n            return decodeURIComponent(escape(Latin1.stringify(w)));\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Malformed UTF-8 data\");\r\n        }\r\n    },\r\n    /**\r\n     * Converts a UTF-8 string to a word array.\r\n     *\r\n     * @param {string} utf8Str The UTF-8 string.\r\n     * @return {Word32Array} The word array.\r\n     * @example\r\n     *   var wordArray = Utf8.parse(utf8Str);\r\n     */\r\n    parse(utf8Str) {\r\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\r\n    }\r\n};\r\n","function makeRandFunction() {\r\n    if (typeof window !== \"undefined\") {\r\n        const c = window.crypto || window.msCrypto;\r\n        if (!c) {\r\n            throw new Error(\"Crypto module not found\");\r\n        }\r\n        return function rand() {\r\n            return c.getRandomValues(new Uint32Array(1))[0];\r\n        };\r\n    }\r\n    else if (typeof global !== \"undefined\" && global.crypto) {\r\n        return function rand() {\r\n            return global.crypto.randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    else if (typeof require === \"function\") {\r\n        return function rand() {\r\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n            // @ts-ignore\r\n            return __non_webpack_require__(\"crypto\").randomBytes(4).readInt32LE();\r\n        };\r\n    }\r\n    throw new Error(\"Unable to find crypto module\");\r\n}\r\nexport const random = makeRandFunction();\r\n"],"sourceRoot":""}